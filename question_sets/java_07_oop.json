[
  {
    "question": "Which of the following are valid ways to create and initialize objects in Java?",
    "correct": [
      "Monster goblin = new Monster(\"Goblin\", 30, 5);",
      "Character hero = new Character(\"Aria\", 100);"
    ],
    "incorrect": [
      "Monster goblin = Monster(\"Goblin\", 30, 5);",
      "new Monster goblin = (\"Goblin\", 30, 5);",
      "Monster goblin = create Monster(\"Goblin\", 30, 5);"
    ],
    "feedback": "The correct answers show proper object creation syntax: variable declaration followed by assignment using 'new' and a constructor call. The incorrect options are missing the 'new' keyword, have incorrect syntax order, or use non-existent keywords like 'create'."
  },
  {
    "question": "What are the benefits of making fields private in a class?",
    "correct": [
      "Prevents external code from setting invalid values like negative health",
      "Allows the class to enforce its own rules and constraints",
      "Makes the code easier to maintain by controlling how data is accessed"
    ],
    "incorrect": [
      "Makes the program run faster by reducing memory usage",
      "Automatically generates getter and setter methods"
    ],
    "feedback": "Private fields provide encapsulation, which protects object state and ensures data integrity. They don't affect performance or automatically generate methods - you must write getters and setters manually."
  },
  {
    "question": "In a Java constructor, which statements are correct about the 'this' keyword?",
    "correct": [
      "this.name = name; assigns the parameter value to the object's field",
      "Using 'this' helps distinguish between parameters and fields with the same name"
    ],
    "incorrect": [
      "this() creates a new instance of the current class",
      "this.new() allocates memory for the object",
      "this refers to the class blueprint rather than the specific object instance"
    ],
    "feedback": "The 'this' keyword refers to the current object instance and is used to access its fields and methods. It doesn't create objects or refer to the class itself - it's a reference to the specific object being constructed."
  },
  {
    "question": "What is the relationship between a class and an object?",
    "correct": [
      "A class is a blueprint, an object is an instance created from that blueprint",
      "Multiple objects can be created from the same class"
    ],
    "incorrect": [
      "A class and an object are the same thing",
      "An object is a blueprint, a class is an instance",
      "You can only create one object from each class"
    ],
    "feedback": "A class defines the structure and behavior (like a blueprint or recipe), while objects are actual instances created from that class. You can create unlimited objects from a single class definition."
  },
  {
    "question": "Which are valid field declarations in a Java class?",
    "correct": [
      "private String name;",
      "private int health;",
      "private boolean isActive;"
    ],
    "incorrect": [
      "field String name;",
      "private String name = ;"
    ],
    "feedback": "Valid field declarations use access modifiers (like private) followed by the data type and variable name. 'field' is not a Java keyword, and assignment operators need a value after the equals sign."
  },
  {
    "question": "What happens when you try to print an object without overriding toString()?",
    "correct": [
      "Java prints the class name followed by a memory address",
      "You get output like 'ClassName@15db9742'"
    ],
    "incorrect": [
      "Java automatically prints all the object's fields",
      "The program crashes with a compilation error",
      "Java prints 'null'"
    ],
    "feedback": "Every class inherits a default toString() method from Object that prints the class name and memory location hash code. Java doesn't automatically display field values - you must override toString() for meaningful output."
  },
  {
    "question": "Which statements about methods in classes are correct?",
    "correct": [
      "Methods can access private fields of the same class",
      "Methods define the behavior that objects can perform",
      "A method with return type void does not return a value"
    ],
    "incorrect": [
      "Methods cannot access private fields",
      "All methods must return a value"
    ],
    "feedback": "Methods within a class can access all fields of that class, including private ones. Methods define object behavior and can have void return type (no return value) or return specific data types."
  },
  {
    "question": "What are characteristics of a proper constructor?",
    "correct": [
      "Has the same name as the class",
      "Has no return type specified",
      "Is called automatically when creating an object with 'new'"
    ],
    "incorrect": [
      "Must return void",
      "Cannot have parameters"
    ],
    "feedback": "Constructors have the exact same name as their class and no return type (not even void). They can take parameters and are automatically invoked when objects are created with the 'new' keyword."
  },
  {
    "question": "Which are valid getter method declarations?",
    "correct": [
      "public int getValue() { return value; }",
      "public String getDescription() { return description; }"
    ],
    "incorrect": [
      "private int getValue() { return value; }",
      "public void getValue() { return value; }",
      "public int getValue() { print value; }"
    ],
    "feedback": "Getters should be public (accessible from outside), have a return type matching the field, and use 'return' statement. Private getters defeat the purpose, void getters can't return values, and 'print' is not a return statement."
  },
  {
    "question": "What makes a good setter method?",
    "correct": [
      "Validates input parameters before setting field values",
      "Has void return type since it doesn't return data",
      "Is declared public to allow controlled access from outside the class"
    ],
    "incorrect": [
      "Always accepts any value passed to it without checking",
      "Returns the new value after setting it"
    ],
    "feedback": "Good setters validate input (like preventing negative health), are public for external access, and typically return void since their job is to modify state, not return data. They should enforce business rules, not blindly accept any input."
  },
  {
    "question": "Which demonstrate proper encapsulation practices?",
    "correct": [
      "Making all fields private and providing public methods to access them",
      "Using setters to validate data before updating fields"
    ],
    "incorrect": [
      "Making all fields and methods public for easy access",
      "Never providing getters or setters for private fields",
      "Making fields protected instead of private"
    ],
    "feedback": "Encapsulation means hiding internal details and controlling access through public methods. Making everything public breaks encapsulation, while never providing access methods makes fields unusable. Protected is less restrictive than private."
  },
  {
    "question": "How do objects interact with each other in Java?",
    "correct": [
      "By calling each other's public methods",
      "By passing objects as parameters to methods",
      "By accessing public fields or methods of other objects"
    ],
    "incorrect": [
      "By directly modifying each other's private fields",
      "By sharing the same memory location"
    ],
    "feedback": "Objects interact through their public interfaces - methods and fields. Private members are inaccessible from other objects. Each object has its own memory space; they communicate through method calls and parameter passing."
  },
  {
    "question": "What is constructor overloading?",
    "correct": [
      "Defining multiple constructors with different parameter lists",
      "Allows different ways to create objects from the same class"
    ],
    "incorrect": [
      "Having constructors with the same parameters but different names",
      "Replacing the default constructor with a custom one",
      "Creating constructors that call methods from the parent class"
    ],
    "feedback": "Constructor overloading means providing multiple constructors with different parameter combinations. All constructors must have the same name (the class name) but different parameter lists, giving flexibility in object creation."
  },
  {
    "question": "Which statements about ArrayList with objects are true?",
    "correct": [
      "ArrayList<SomeClass> can store multiple objects of that class type",
      "You can loop through an ArrayList to process each object",
      "Objects in ArrayList maintain their individual state"
    ],
    "incorrect": [
      "ArrayList can only store primitive data types like int and char",
      "All objects in an ArrayList share the same field values"
    ],
    "feedback": "ArrayList can store objects of any class type. Each object in the collection maintains its own independent state and can be processed individually through loops or direct access."
  },
  {
    "question": "What does the @Override annotation indicate?",
    "correct": [
      "The method replaces an inherited method from a parent class",
      "Enables compiler checking to ensure the method signature matches the parent"
    ],
    "incorrect": [
      "The method is abstract and must be implemented by subclasses",
      "The method cannot be called from outside the class",
      "The method automatically generates getter and setter methods"
    ],
    "feedback": "@Override indicates that a method is replacing (overriding) an inherited method. It helps catch errors if the method signature doesn't match the parent class method and has no effect on access control or code generation."
  },
  {
    "question": "Which demonstrate the difference between state and behavior in objects?",
    "correct": [
      "Fields represent state, methods represent behavior",
      "An object's data values are state, its actions are behavior",
      "State is what an object knows, behavior is what an object can do"
    ],
    "incorrect": [
      "State and behavior are the same thing in object-oriented programming",
      "Methods represent state, fields represent behavior"
    ],
    "feedback": "State refers to an object's data (stored in fields), while behavior refers to actions the object can perform (defined by methods). This separation is fundamental to object-oriented design."
  },
  {
    "question": "What happens when you create multiple objects from the same class?",
    "correct": [
      "Each object gets its own copy of all fields",
      "Objects have independent state but share the same methods",
      "Changes to one object's fields don't affect other objects"
    ],
    "incorrect": [
      "All objects share the same field values",
      "Objects cannot have different values for the same field type"
    ],
    "feedback": "Each object instance has its own memory space and field values. While they share method definitions from the class, their data is completely independent. Modifying one object never affects another object's state."
  },
  {
    "question": "Which are correct about the main method in object-oriented programs?",
    "correct": [
      "public static void main(String[] args) is the correct signature",
      "The main method serves as the program's entry point"
    ],
    "incorrect": [
      "main method should be private to protect it from external access",
      "main method must be declared inside every class",
      "main method can have any return type as long as it's consistent"
    ],
    "feedback": "The main method must be public (accessible), static (callable without creating an object), and have void return type with String array parameter. Only one class needs a main method to serve as the program entry point."
  },
  {
    "question": "How should you handle invalid input in constructors?",
    "correct": [
      "Validate parameters and set reasonable defaults for invalid values",
      "Clamp values to acceptable ranges (like setting negative health to 0)"
    ],
    "incorrect": [
      "Always throw an exception and crash the program",
      "Ignore invalid values and proceed with whatever was passed in",
      "Print error messages but still use the invalid values"
    ],
    "feedback": "Good constructors validate input and handle invalid data gracefully by setting safe defaults or clamping to valid ranges. Crashing or using invalid data creates unreliable programs, while error messages alone don't fix the underlying problem."
  },
  {
    "question": "What is the purpose of visibility modifiers like public and private?",
    "correct": [
      "Control which parts of a class can be accessed from other classes",
      "Enforce encapsulation by hiding implementation details",
      "Create clear interfaces between objects"
    ],
    "incorrect": [
      "Optimize memory usage by reducing object size",
      "Automatically generate documentation for the class"
    ],
    "feedback": "Visibility modifiers control access to class members, supporting encapsulation by hiding internal details and exposing only necessary interfaces. They don't affect memory usage or documentation - they're about access control and design."
  },
  {
    "question": "Which statements about method parameters vs. fields are accurate?",
    "correct": [
      "Parameters exist only during method execution",
      "Fields persist as long as the object exists",
      "Parameters receive values when the method is called"
    ],
    "incorrect": [
      "Parameters and fields have the same lifetime",
      "Fields are automatically passed to all methods"
    ],
    "feedback": "Parameters are temporary variables that exist only while a method runs and receive values from method calls. Fields are permanent object data that persist throughout the object's lifetime and must be explicitly accessed within methods."
  },
  {
    "question": "What makes object-oriented design better than using only functions?",
    "correct": [
      "Objects bundle related data and behavior together",
      "Objects model real-world concepts more naturally",
      "Object state is protected and managed consistently"
    ],
    "incorrect": [
      "Object-oriented programs always run faster than function-based programs",
      "Objects eliminate the need for any functions or methods"
    ],
    "feedback": "OOP's advantages are organizational and conceptual: bundling related data/behavior, modeling real-world entities naturally, and maintaining data integrity. Performance depends on implementation, not paradigm, and objects still use methods (functions) internally."
  },
  {
    "question": "How do you properly call methods on objects?",
    "correct": [
      "Use dot notation: objectName.methodName()",
      "Pass required arguments that match the method's parameter list",
      "The method executes using that specific object's field values"
    ],
    "incorrect": [
      "Call methods directly without specifying which object: methodName()",
      "All methods automatically receive all object fields as parameters"
    ],
    "feedback": "Method calls require specifying which object to call the method on using dot notation, followed by parentheses containing any required arguments. Methods automatically access their object's fields without needing them as parameters."
  },
  {
    "question": "Which demonstrate good toString() method practices?",
    "correct": [
      "Return a String that describes the object's current state",
      "Include key field values in a readable format",
      "Use the @Override annotation"
    ],
    "incorrect": [
      "Print information directly instead of returning a String",
      "Always return just the object's memory address"
    ],
    "feedback": "Good toString() methods return descriptive strings containing important field values and use @Override annotation. They should return strings, not print directly, and provide meaningful information instead of default memory addresses."
  },
  {
    "question": "What happens during object creation with the 'new' keyword?",
    "correct": [
      "Memory is allocated for the new object",
      "The constructor is automatically called to initialize the object",
      "Field values are set according to constructor parameters or defaults"
    ],
    "incorrect": [
      "The class blueprint is copied into memory",
      "All existing objects of the same type are updated"
    ],
    "feedback": "The 'new' keyword allocates memory for an individual object instance, then calls the constructor to initialize that specific object. The class definition isn't copied, and other objects are unaffected."
  },
  {
    "question": "Which are characteristics of well-designed classes?",
    "correct": [
      "Fields are private with public methods providing controlled access",
      "Constructors ensure objects start in valid states",
      "Methods enforce business rules and validate inputs"
    ],
    "incorrect": [
      "All fields and methods should be public for maximum flexibility",
      "Classes should never validate input since that's the caller's responsibility"
    ],
    "feedback": "Well-designed classes use encapsulation (private fields), ensure objects are properly initialized through constructors, and maintain data integrity by validating inputs. Making everything public breaks encapsulation and removes protection."
  },
  {
    "question": "How do collections like ArrayList work with custom objects?",
    "correct": [
      "ArrayList<CustomClass> stores references to objects of that type",
      "Each object in the collection maintains its own independent state",
      "You can call methods on objects retrieved from the collection"
    ],
    "incorrect": [
      "Collections automatically merge all objects into a single combined object",
      "Objects lose their individual identity when added to collections"
    ],
    "feedback": "Collections store references to individual objects, preserving each object's independent state and identity. You can retrieve objects from collections and interact with them normally - they don't merge or lose their individual properties."
  },
  {
    "question": "What is the significance of the dot operator (.) in object-oriented programming?",
    "correct": [
      "Accesses fields and methods of a specific object",
      "Separates the object name from the member being accessed",
      "Works with both public fields and public methods"
    ],
    "incorrect": [
      "Creates a new instance of the object",
      "Only works with static methods and fields"
    ],
    "feedback": "The dot operator provides access to an object's members (fields and methods). It specifies which object you're working with and which of its members you want to access. It doesn't create objects and works with instance members, not just static ones."
  },
  {
    "question": "Which statements about constructor parameters are correct?",
    "correct": [
      "Constructor parameters provide initial values for object fields",
      "Parameter names can match field names when using 'this' keyword",
      "Constructors can have different parameter lists (overloading)"
    ],
    "incorrect": [
      "Constructor parameters are automatically stored as object fields",
      "All constructors must have the same number of parameters"
    ],
    "feedback": "Constructor parameters supply initialization data and require explicit assignment to fields (they're not automatically stored). Using 'this' resolves naming conflicts, and constructor overloading allows different parameter combinations for flexible object creation."
  },
  {
    "question": "What are the key principles demonstrated in object-oriented programming?",
    "correct": [
      "Encapsulation through private fields and public methods",
      "Object interaction through method calls and parameter passing",
      "State management where each object maintains its own data"
    ],
    "incorrect": [
      "All classes should inherit from a common base class",
      "Objects should directly access each other's private fields for efficiency"
    ],
    "feedback": "The key OOP principles include encapsulation (private fields with controlled access), object collaboration (objects calling methods on other objects), and independent state management. Direct field access violates encapsulation, and inheritance isn't required for basic object interaction."
  }
]