[
  {
    "question": "What is the main advantage of ArrayList over regular arrays?",
    "correct": [
      "Dynamic sizing that grows and shrinks automatically"
    ],
    "incorrect": [
      "Faster access to elements by index",
      "Uses less memory for storage",
      "Can store primitive types directly",
      "Maintains elements in sorted order"
    ],
    "feedback": "ArrayList's main advantage is dynamic sizing - it automatically resizes as you add or remove elements, unlike arrays which have fixed size. While arrays are slightly faster for index access and use less memory, ArrayList provides convenience and flexibility. ArrayList cannot store primitives directly (requires wrapper classes) and doesn't maintain sorted order unless you explicitly sort it."
  },
  {
    "question": "Which generic type declarations are syntactically correct?",
    "correct": [
      "ArrayList<String> names = new ArrayList<>();",
      "HashMap<String, Integer> scores = new HashMap<>();"
    ],
    "incorrect": [
      "ArrayList<string> names = new ArrayList<>();",
      "HashMap<String Integer> scores = new HashMap<>();",
      "ArrayList(String) names = new ArrayList();"
    ],
    "feedback": "Generic types use angle brackets <> with proper capitalization: String (not string), Integer (not int for collections). The diamond operator <> on the right side lets Java infer the type. Parameters are separated by commas in maps. Parentheses instead of angle brackets and missing generic syntax are incorrect."
  },
  {
    "question": "Which ArrayList methods correctly add elements?",
    "correct": [
      "list.add(\"item\") adds to the end",
      "list.add(0, \"item\") inserts at the beginning",
      "list.addAll(otherList) adds multiple elements"
    ],
    "incorrect": [
      "list.insert(\"item\") adds to the end",
      "list.append(0, \"item\") inserts at the beginning"
    ],
    "feedback": "ArrayList uses add() for appending to the end, add(index, element) for inserting at specific positions, and addAll() for adding entire collections. Java doesn't have insert() or append() methods for ArrayList - these are method names from other programming languages or different Java classes."
  },
  {
    "question": "What does this code output: ArrayList<String> list = new ArrayList<>(); list.add(\"A\"); list.add(\"B\"); list.add(0, \"C\"); System.out.println(list.get(1));?",
    "correct": [
      "A",
      "The element that was shifted to position 1",
      "The original first element after insertion",
      "\"A\" because it moved from index 0 to index 1"
    ],
    "incorrect": [
      "C"
    ],
    "feedback": "When \"C\" is inserted at index 0, it becomes the first element. The original elements \"A\" and \"B\" shift right, so \"A\" moves from index 0 to index 1, and \"B\" moves to index 2. Therefore, list.get(1) returns \"A\", not \"C\" which is at index 0."
  },
  {
    "question": "What are the characteristics of LinkedList compared to ArrayList?",
    "correct": [
      "Faster insertions and deletions at the beginning",
      "Better for queue-like operations",
      "Slower random access by index",
      "More efficient for frequent modifications in the middle",
      "Provides addFirst() and addLast() methods"
    ],
    "incorrect": [],
    "feedback": "LinkedList excels at insertions and deletions, especially at the beginning or middle, because it only needs to reconnect links rather than shift elements. It's perfect for queue operations and provides special methods like addFirst() and addLast(). However, accessing elements by index is slower because it must traverse the chain from the beginning."
  },
  {
    "question": "Which statement correctly creates an empty HashSet of strings?",
    "correct": [
      "HashSet<String> set = new HashSet<>();"
    ],
    "incorrect": [
      "HashSet set = new HashSet<String>();",
      "HashSet<String> set = new HashSet<String>();",
      "Set<String> set = new Set<>();",
      "HashSet<String> set = HashSet.create();"
    ],
    "feedback": "The modern syntax uses the diamond operator <> on the right side: new HashSet<>(). While new HashSet<String>() works, it's more verbose. Raw types without generics (HashSet set) lose type safety. You cannot instantiate the Set interface directly, and HashSet doesn't have a create() factory method."
  },
  {
    "question": "What happens when you add duplicate elements to a HashSet?",
    "correct": [
      "Duplicates are automatically ignored",
      "The set size doesn't increase",
      "add() returns false for duplicates",
      "Only one copy of each element is stored"
    ],
    "incorrect": [
      "A DuplicateElementException is thrown"
    ],
    "feedback": "HashSet automatically prevents duplicates - when you try to add an element that already exists, the add() method returns false and the set remains unchanged. No exception is thrown; it simply ignores the duplicate. This is the defining feature of sets: ensuring uniqueness of elements."
  },
  {
    "question": "Which collections maintain the insertion order of elements?",
    "correct": [
      "ArrayList",
      "LinkedList"
    ],
    "incorrect": [
      "HashSet",
      "HashMap",
      "TreeSet"
    ],
    "feedback": "ArrayList and LinkedList maintain insertion order - elements appear in the same sequence you added them. HashSet and HashMap do not guarantee any order, storing elements based on hash values for performance. TreeSet maintains sorted order, not insertion order."
  },
  {
    "question": "How do you check if an ArrayList contains a specific element?",
    "correct": [
      "list.contains(element)"
    ],
    "incorrect": [
      "list.hasElement(element)",
      "list.includes(element)",
      "list.find(element) != null"
    ],
    "feedback": "ArrayList uses the contains(element) method which returns a boolean indicating whether the element exists in the list. Java doesn't have hasElement(), includes(), or find() methods for ArrayList. The contains() method uses the equals() method to compare elements."
  },
  {
    "question": "What does HashMap store?",
    "correct": [
      "Key-value pairs where each key maps to one value"
    ],
    "incorrect": [
      "Only keys without associated values",
      "Multiple values for each key",
      "Elements in alphabetical order",
      "Duplicate keys with different values"
    ],
    "feedback": "HashMap stores key-value pairs where each unique key is associated with exactly one value. Keys cannot be duplicated (adding the same key overwrites the previous value), but multiple keys can have the same value. HashMap doesn't maintain any particular order of elements."
  },
  {
    "question": "Which HashMap methods are used correctly?",
    "correct": [
      "map.put(\"key\", \"value\") stores a key-value pair",
      "map.get(\"key\") retrieves the value for a key"
    ],
    "incorrect": [
      "map.add(\"key\", \"value\") stores a key-value pair",
      "map.getValue(\"key\") retrieves the value for a key",
      "map.contains(\"key\") checks if a key exists"
    ],
    "feedback": "HashMap uses put() to store key-value pairs and get() to retrieve values. It doesn't have add(), getValue(), or contains() methods. To check if a key exists, use containsKey(). To check if a value exists, use containsValue()."
  },
  {
    "question": "What happens when you call get() on a HashMap with a non-existent key?",
    "correct": [
      "Returns null",
      "No exception is thrown",
      "You should check for null before using the result"
    ],
    "incorrect": [
      "Throws a KeyNotFoundException",
      "Returns an empty string",
      "Throws a NullPointerException"
    ],
    "feedback": "HashMap.get() returns null when the key doesn't exist, without throwing any exception. This requires null checking before using the result to avoid NullPointerException. Java doesn't have a KeyNotFoundException, and it doesn't return empty strings or other default values automatically."
  },
  {
    "question": "Which loop correctly iterates through all keys in a HashMap called 'map'?",
    "correct": [
      "for (String key : map.keySet()) { }"
    ],
    "incorrect": [
      "for (String key : map.keys()) { }",
      "for (String key : map) { }",
      "for (int i = 0; i < map.size(); i++) { String key = map.get(i); }"
    ],
    "feedback": "HashMap uses keySet() method to return all keys as a Set, which can be used in enhanced for loops. HashMap doesn't have a keys() method, cannot be iterated directly, and doesn't support index-based access like get(i) since it's not an ordered collection."
  },
  {
    "question": "What does Collections.sort(list) do to the original list?",
    "correct": [
      "Modifies the original list to be in sorted order",
      "Rearranges elements alphabetically for strings",
      "Changes the list permanently",
      "Sorts in ascending order by default"
    ],
    "incorrect": [
      "Returns a new sorted list without changing the original"
    ],
    "feedback": "Collections.sort() modifies the original list in place, rearranging elements into sorted order (alphabetical for strings, numerical for numbers). It doesn't create a new list - the original list is permanently changed. If you need to keep the original unchanged, create a copy first."
  },
  {
    "question": "Which Collections utility methods produce random results?",
    "correct": [
      "Collections.shuffle(list)"
    ],
    "incorrect": [
      "Collections.sort(list)",
      "Collections.reverse(list)",
      "Collections.frequency(list, item)",
      "Collections.max(list)"
    ],
    "feedback": "Only Collections.shuffle() produces random results by randomly rearranging elements. The other methods are deterministic: sort() always produces the same alphabetical/numerical order, reverse() always flips the order the same way, frequency() always counts the same, and max() always finds the same largest element."
  },
  {
    "question": "How do you count occurrences of an element in a collection?",
    "correct": [
      "Collections.frequency(collection, element)"
    ],
    "incorrect": [
      "collection.count(element)",
      "collection.frequency(element)",
      "Collections.count(collection, element)"
    ],
    "feedback": "Collections.frequency(collection, element) is the correct method to count how many times an element appears in any collection. The collection classes themselves don't have count() or frequency() methods - this functionality is provided by the Collections utility class."
  },
  {
    "question": "Which statement about generic types in collections is correct?",
    "correct": [
      "Generics provide type safety at compile time",
      "Prevent ClassCastException errors",
      "Eliminate the need for casting when retrieving elements",
      "Specified with angle bracket notation",
      "Help catch type mismatches early"
    ],
    "incorrect": [],
    "feedback": "Generic types provide compile-time type safety, preventing you from adding wrong types to collections and eliminating the need to cast when retrieving elements. They use angle bracket notation like <String> and help catch type mismatches during compilation rather than at runtime, preventing ClassCastException errors."
  },
  {
    "question": "What is the difference between HashSet and ArrayList regarding duplicates?",
    "correct": [
      "HashSet prevents duplicates automatically",
      "ArrayList allows multiple copies of the same element",
      "HashSet ensures uniqueness",
      "ArrayList can have repeated elements"
    ],
    "incorrect": [
      "ArrayList prevents duplicates automatically"
    ],
    "feedback": "HashSet automatically prevents duplicates - each element can only appear once. ArrayList allows duplicates, so you can add the same element multiple times and it will store multiple copies. This is a fundamental difference between sets (unique elements) and lists (ordered elements with possible duplicates)."
  },
  {
    "question": "Which methods correctly remove elements from an ArrayList?",
    "correct": [
      "list.remove(0) removes element at index 0",
      "list.remove(\"item\") removes the first occurrence of \"item\"",
      "list.clear() removes all elements"
    ],
    "incorrect": [
      "list.delete(0) removes element at index 0",
      "list.removeAll() removes all elements"
    ],
    "feedback": "ArrayList uses remove(index) to remove by position, remove(object) to remove by value, and clear() to remove everything. Java doesn't have delete() methods for collections, and removeAll() takes a collection parameter to remove multiple specific elements, not all elements."
  },
  {
    "question": "When should you use LinkedList instead of ArrayList?",
    "correct": [
      "Frequent insertions at the beginning of the list",
      "Implementing queue or stack behavior",
      "Many insertions and deletions in the middle"
    ],
    "incorrect": [
      "Random access to elements by index",
      "When memory usage is critical",
      "For simple add-to-end operations"
    ],
    "feedback": "Use LinkedList when you frequently insert/delete at the beginning or middle, or when implementing queue/stack structures. For random access by index, memory efficiency, or simple append operations, ArrayList is better. LinkedList's strength is modifying the structure, not accessing elements by position."
  },
  {
    "question": "What does this code do: HashMap<String, Integer> map = new HashMap<>(); map.put(\"score\", 100); map.put(\"score\", 200); System.out.println(map.get(\"score\"));?",
    "correct": [
      "Prints 200"
    ],
    "incorrect": [
      "Prints 100"
    ],
    "feedback": "HashMap keys are unique, so when you put() the same key twice, the second value (200) overwrites the first value (100). The map only contains one entry for \"score\" with the value 200. This is fundamental HashMap behavior - each key maps to exactly one value."
  },
  {
    "question": "Which collections are best for preventing duplicate elements?",
    "correct": [
      "HashSet automatically prevents duplicates",
      "Any Set implementation ensures uniqueness"
    ],
    "incorrect": [
      "ArrayList automatically prevents duplicates",
      "HashMap prevents duplicate elements",
      "LinkedList ensures no repeated elements"
    ],
    "feedback": "Set implementations like HashSet automatically prevent duplicates - this is their defining characteristic. ArrayList and LinkedList allow duplicates. HashMap prevents duplicate keys, but can have duplicate values, and its primary purpose is key-value mapping, not duplicate prevention of elements."
  },
  {
    "question": "How do you safely retrieve and use a value from a HashMap?",
    "correct": [
      "Check if the returned value is not null before using it",
      "Use containsKey() to verify the key exists first",
      "Handle the case where get() returns null"
    ],
    "incorrect": [
      "HashMap.get() never returns null",
      "Wrap the get() call in a try-catch block"
    ],
    "feedback": "Always check for null when using HashMap.get() because it returns null for non-existent keys. You can either check if (value != null) after calling get(), or use containsKey() first to verify the key exists. get() doesn't throw exceptions that require try-catch, but null values can cause NullPointerException if used without checking."
  },
  {
    "question": "Which Collections methods require the list to be sorted first?",
    "correct": [
      "Collections.binarySearch(list, element)"
    ],
    "incorrect": [
      "Collections.shuffle(list)",
      "Collections.reverse(list)",
      "Collections.frequency(list, element)",
      "Collections.max(list)"
    ],
    "feedback": "Only Collections.binarySearch() requires the list to be sorted beforehand because it uses a binary search algorithm that relies on ordered data. The other methods work on any list regardless of order: shuffle() randomizes any order, reverse() flips any order, frequency() counts in any order, and max() finds the largest element regardless of order."
  },
  {
    "question": "What is the purpose of the diamond operator <> in Java collections?",
    "correct": [
      "Allows Java to infer the generic type from the left side",
      "Reduces code verbosity",
      "Provides same type safety as explicit generics",
      "Introduced to simplify generic declarations"
    ],
    "incorrect": [
      "Required for all collection declarations"
    ],
    "feedback": "The diamond operator <> lets Java automatically infer the generic type from the left side of the assignment, so you can write new ArrayList<>() instead of new ArrayList<String>(). It provides the same type safety while reducing verbosity. While not required (you can still use explicit types), it's the modern preferred syntax."
  },
  {
    "question": "Which operations are more efficient with HashSet than ArrayList?",
    "correct": [
      "Checking if an element exists (contains)",
      "Preventing duplicate additions",
      "Membership testing with large datasets"
    ],
    "incorrect": [
      "Accessing elements by index position",
      "Maintaining insertion order",
      "Iterating through all elements in sequence"
    ],
    "feedback": "HashSet excels at membership testing (contains) and duplicate prevention due to its hash-based internal structure, making these operations very fast even with large datasets. ArrayList is better for index access, maintaining order, and sequential iteration. HashSet trades off order and index access for fast uniqueness operations."
  },
  {
    "question": "How do you iterate through both keys and values in a HashMap?",
    "correct": [
      "for (String key : map.keySet()) { String value = map.get(key); }"
    ],
    "incorrect": [
      "for (Entry entry : map.entries()) { }",
      "for (String key, String value : map) { }"
    ],
    "feedback": "The standard approach is to iterate through keySet() and use get() for each key to retrieve the corresponding value. While HashMap has an entrySet() method (not entries()), the keySet() approach is more commonly used and easier to understand. Java doesn't support multiple variable declarations in enhanced for loops."
  },
  {
    "question": "What are the main differences between List and Set interfaces?",
    "correct": [
      "List allows duplicates, Set prevents them",
      "List maintains insertion order, Set may not",
      "List provides index-based access, Set does not",
      "List supports positional operations, Set focuses on uniqueness"
    ],
    "incorrect": [
      "Set allows duplicates, List prevents them"
    ],
    "feedback": "Lists (ArrayList, LinkedList) allow duplicate elements and provide index-based access with methods like get(index). Sets (HashSet) automatically prevent duplicates and focus on uniqueness rather than position. Lists maintain order and support positional operations, while Sets prioritize fast membership testing and uniqueness enforcement."
  },
  {
    "question": "Which statement correctly creates a HashMap with String keys and Integer values?",
    "correct": [
      "HashMap<String, Integer> map = new HashMap<>();"
    ],
    "incorrect": [
      "HashMap<String, int> map = new HashMap<>();",
      "HashMap<string, Integer> map = new HashMap<>();",
      "HashMap(String, Integer) map = new HashMap();",
      "Map<String, Integer> map = new Map<>();"
    ],
    "feedback": "Correct syntax uses HashMap<String, Integer> with proper capitalization (String, Integer not int) and angle brackets. Primitive types like int cannot be used as generic parameters - use wrapper classes like Integer. You cannot instantiate the Map interface directly; you need a concrete class like HashMap."
  },
  {
    "question": "What happens when you modify a collection while iterating through it with an enhanced for loop?",
    "correct": [
      "Can cause unpredictable behavior or exceptions",
      "Generally not safe to add or remove elements",
      "May throw ConcurrentModificationException",
      "Should use traditional for loops for modifications"
    ],
    "incorrect": [
      "Automatically handles the modifications safely"
    ],
    "feedback": "Modifying collections during enhanced for loop iteration can cause ConcurrentModificationException or unpredictable behavior because the iterator becomes invalid when the collection structure changes. If you need to modify while iterating, use traditional for loops (iterating backwards for removals) or collect changes to apply after iteration."
  }
]