[
  {
    "question": "What is the main advantage of ArrayList over regular arrays?",
    "correct": [
      "Dynamic sizing that grows and shrinks automatically"
    ],
    "incorrect": [
      "Faster access to elements by index",
      "Uses less memory for storage",
      "Can store primitive types directly",
      "Maintains elements in sorted order"
    ],
    "feedback": "ArrayList's main advantage is dynamic sizing - it automatically resizes as you add or remove elements, unlike arrays which have fixed size. While arrays are slightly faster for index access and use less memory, ArrayList provides convenience and flexibility. ArrayList cannot store primitives directly (requires wrapper classes) and doesn't maintain sorted order unless you explicitly sort it."
  },
  {
    "question": "Which ArrayList methods are used to add elements?",
    "correct": [
      "add(element) to append to the end",
      "add(index, element) to insert at a specific position"
    ],
    "incorrect": [
      "put(element) to add elements",
      "insert(element) to add elements",
      "append(element) to add elements"
    ],
    "feedback": "ArrayList uses add() to append elements and add(index, element) to insert at specific positions. Java doesn't have put() for lists (that's for maps), insert() doesn't exist for ArrayList, and append() isn't an ArrayList method."
  },
  {
    "question": "What does ArrayList.get(index) return if the index is out of bounds?",
    "correct": [
      "Throws IndexOutOfBoundsException"
    ],
    "incorrect": [
      "Returns null",
      "Returns the last element",
      "Returns an empty string",
      "Returns -1"
    ],
    "feedback": "ArrayList throws IndexOutOfBoundsException for invalid indices, providing clear error messages. It doesn't return null, default values, or -1 like some other methods might. This exception helps catch programming errors early."
  },
  {
    "question": "Which statements about ArrayList.indexOf() are true?",
    "correct": [
      "Returns -1 if the element is not found",
      "Returns the position of the first occurrence"
    ],
    "incorrect": [
      "Returns null if the element is not found",
      "Throws an exception if the element is not found",
      "Returns the position of the last occurrence"
    ],
    "feedback": "indexOf() returns the index of the first matching element, or -1 if not found. It doesn't return null (it returns an int), doesn't throw exceptions for missing elements, and finds the first occurrence, not the last (that's lastIndexOf())."
  },
  {
    "question": "What happens when you call ArrayList.remove(object)?",
    "correct": [
      "Removes the first occurrence of the object and returns true if found"
    ],
    "incorrect": [
      "Removes all occurrences of the object",
      "Returns the removed object",
      "Throws an exception if the object isn't found",
      "Removes the object at the specified index"
    ],
    "feedback": "remove(object) removes only the first occurrence and returns a boolean (true if found and removed, false otherwise). To remove all occurrences, you'd need a loop. It doesn't return the object itself or throw exceptions. For index-based removal, use remove(int index)."
  },
  {
    "question": "Which is NOT a valid way to iterate through an ArrayList?",
    "correct": [
      "while (list.hasNext()) { }"
    ],
    "incorrect": [
      "for (String item : list) { }",
      "for (int i = 0; i < list.size(); i++) { }",
      "Using an Iterator object",
      "list.forEach(item -> System.out.println(item))"
    ],
    "feedback": "hasNext() is a method on Iterator objects, not on ArrayList itself. Valid iteration includes enhanced for loops, traditional for loops with indices, explicit Iterator usage, and forEach with lambda expressions."
  },
  {
    "question": "What does the diamond operator <> do in ArrayList creation?",
    "correct": [
      "Allows Java to infer the generic type from the left side"
    ],
    "incorrect": [
      "Creates a sorted ArrayList",
      "Specifies the initial capacity",
      "Makes the ArrayList immutable",
      "Enables duplicate prevention"
    ],
    "feedback": "The diamond operator <> lets Java infer the generic type from the variable declaration, so you can write new ArrayList<>() instead of new ArrayList<String>(). It doesn't affect sorting, capacity, mutability, or duplicate handling."
  },
  {
    "question": "When should you use LinkedList instead of ArrayList?",
    "correct": [
      "Frequent insertions and deletions at the beginning or middle"
    ],
    "incorrect": [
      "Need to access elements by index frequently",
      "Want to prevent duplicate elements",
      "Need to sort elements automatically",
      "Working with key-value pairs"
    ],
    "feedback": "LinkedList excels at insertions/deletions at the beginning or middle because it only needs to adjust links, not shift elements. ArrayList is better for frequent index access. For duplicates use HashSet, for automatic sorting use TreeSet, and for key-value pairs use HashMap."
  },
  {
    "question": "Which LinkedList methods are NOT available in ArrayList?",
    "correct": [
      "addFirst() and addLast()",
      "removeFirst() and removeLast()"
    ],
    "incorrect": [
      "add() and remove()",
      "get() and set()",
      "contains() and isEmpty()"
    ],
    "feedback": "LinkedList has special methods for beginning/end operations like addFirst(), addLast(), removeFirst(), and removeLast() that ArrayList doesn't have. Both share common List methods like add(), remove(), get(), set(), contains(), and isEmpty()."
  },
  {
    "question": "What is the key feature that distinguishes HashSet from ArrayList?",
    "correct": [
      "HashSet automatically prevents duplicate elements"
    ],
    "incorrect": [
      "HashSet maintains insertion order",
      "HashSet allows index-based access",
      "HashSet is faster for all operations",
      "HashSet can only store strings"
    ],
    "feedback": "HashSet's defining feature is automatic duplicate prevention - each element appears only once. Unlike ArrayList, HashSet doesn't maintain order, doesn't support index access, isn't universally faster, and can store any object type."
  },
  {
    "question": "What happens when you add a duplicate element to a HashSet?",
    "correct": [
      "The add() method returns false and the duplicate is not added"
    ],
    "incorrect": [
      "An exception is thrown",
      "The old element is replaced with the new one",
      "Both elements are stored",
      "The HashSet is cleared automatically"
    ],
    "feedback": "When you try to add a duplicate to a HashSet, the add() method simply returns false and the duplicate is silently ignored. No exception is thrown, nothing is replaced, and the set remains unchanged with only the original element."
  },
  {
    "question": "Which operations can you NOT perform on a HashSet?",
    "correct": [
      "Access elements by index position"
    ],
    "incorrect": [
      "Check if an element exists with contains()",
      "Iterate through all elements with a for loop",
      "Remove specific elements",
      "Get the number of elements with size()"
    ],
    "feedback": "HashSet doesn't support index-based access like get(0) because it doesn't maintain a specific order. You can check membership, iterate (though order is unpredictable), remove elements, and get the size."
  },
  {
    "question": "What does HashMap store?",
    "correct": [
      "Key-value pairs where each key maps to one value"
    ],
    "incorrect": [
      "Only unique values without keys",
      "Multiple values for each key",
      "Elements in sorted order",
      "Only String data types"
    ],
    "feedback": "HashMap stores key-value pairs - each unique key maps to exactly one value. It's not like a Set (which stores single values), doesn't maintain multiple values per key (without extra structure), doesn't guarantee order, and can store any object types as specified by generics."
  },
  {
    "question": "Which HashMap methods check for existence?",
    "correct": [
      "containsKey() checks if a key exists",
      "containsValue() checks if a value exists"
    ],
    "incorrect": [
      "contains() checks for both keys and values",
      "hasKey() checks if a key exists",
      "exists() checks if a key exists"
    ],
    "feedback": "HashMap uses containsKey() and containsValue() for existence checking. There's no generic contains() method (that's for Collection types), and hasKey() and exists() don't exist in HashMap."
  },
  {
    "question": "What does HashMap.get(key) return if the key doesn't exist?",
    "correct": [
      "Returns null"
    ],
    "incorrect": [
      "Throws a KeyNotFoundException",
      "Returns an empty string",
      "Returns -1",
      "Creates a new entry with default value"
    ],
    "feedback": "HashMap.get() returns null when a key doesn't exist, which is why you should always check for null before using the result. It doesn't throw exceptions for missing keys, doesn't return default primitive values, and doesn't auto-create entries."
  },
  {
    "question": "What happens when you put() a key that already exists in a HashMap?",
    "correct": [
      "The old value is replaced and the old value is returned"
    ],
    "incorrect": [
      "An exception is thrown",
      "Both values are stored in a list",
      "The operation is ignored and nothing changes",
      "The key is removed from the map"
    ],
    "feedback": "When you put() with an existing key, HashMap replaces the old value with the new one and returns the old value. No exception is thrown, values aren't accumulated, the operation isn't ignored, and keys remain in the map."
  },
  {
    "question": "Which collection type would you use to build a song-to-artist database?",
    "correct": [
      "HashMap<String, String>"
    ],
    "incorrect": [
      "ArrayList<String>",
      "HashSet<String>",
      "LinkedList<String>",
      "TreeSet<String>"
    ],
    "feedback": "HashMap is perfect for relationships like song-to-artist because it connects keys (songs) to values (artists). ArrayList and LinkedList store simple lists, HashSet stores unique elements without relationships, and TreeSet adds sorting but still no key-value pairs."
  },
  {
    "question": "What does Collections.sort() do to the original collection?",
    "correct": [
      "Modifies the original collection by sorting it in place"
    ],
    "incorrect": [
      "Creates a new sorted copy and leaves the original unchanged",
      "Throws an exception if the collection is unsorted",
      "Only works with ArrayList, not other List types",
      "Sorts in descending order by default"
    ],
    "feedback": "Collections.sort() modifies the original list in place - it doesn't create a copy. It works with any List type (not just ArrayList), doesn't throw exceptions on unsorted data, and sorts in ascending (natural) order by default."
  },
  {
    "question": "Which Collections utility methods modify the original collection?",
    "correct": [
      "Collections.shuffle() randomizes the order",
      "Collections.reverse() flips the order"
    ],
    "incorrect": [
      "Collections.frequency() counts occurrences",
      "Collections.max() finds the largest element",
      "Collections.min() finds the smallest element"
    ],
    "feedback": "shuffle() and reverse() modify the original collection in place. frequency(), max(), and min() are read-only operations that return values without changing the collection."
  },
  {
    "question": "What requirement must be met before using Collections.binarySearch()?",
    "correct": [
      "The list must be sorted in ascending order"
    ],
    "incorrect": [
      "The list must be an ArrayList specifically",
      "The list must contain only unique elements",
      "The list must have at least 10 elements",
      "The list must contain only String objects"
    ],
    "feedback": "binarySearch() requires the list to be sorted in ascending order to work correctly - otherwise results are unpredictable. It works with any List type, doesn't require unique elements, has no minimum size requirement, and works with any comparable type."
  },
  {
    "question": "What does Collections.frequency(collection, element) return?",
    "correct": [
      "The number of times the element appears in the collection"
    ],
    "incorrect": [
      "True if the element appears at least once",
      "The index of the first occurrence",
      "A list of all positions where the element appears",
      "The percentage of the collection that is this element"
    ],
    "feedback": "frequency() returns an integer count of how many times the element appears. It doesn't return boolean values, indices, position lists, or percentages."
  },
  {
    "question": "Which generic type declarations are correct for storing song ratings?",
    "correct": [
      "HashMap<String, Double> for song title to rating",
      "ArrayList<Double> for a list of ratings"
    ],
    "incorrect": [
      "ArrayList<double> for primitive ratings",
      "HashMap<String, double> for song to primitive rating",
      "HashSet<int> for unique play counts"
    ],
    "feedback": "Collections require wrapper classes (Double, Integer) not primitives (double, int). HashMap<String, Double> and ArrayList<Double> are correct. You cannot use ArrayList<double>, HashMap<String, double>, or HashSet<int> - these cause compilation errors."
  },
  {
    "question": "What is the performance difference between ArrayList and LinkedList for get(index)?",
    "correct": [
      "ArrayList is much faster - constant time vs linear time"
    ],
    "incorrect": [
      "LinkedList is much faster for index access",
      "They have identical performance",
      "It depends on the size of the collection",
      "LinkedList is faster for small indices only"
    ],
    "feedback": "ArrayList has direct index access (constant time), while LinkedList must traverse from the beginning (linear time). This makes ArrayList significantly faster for get() operations. The performance gap widens as the collection grows and the accessed index increases."
  },
  {
    "question": "Which is NOT a valid reason to choose ArrayList over arrays?",
    "correct": [
      "ArrayList is faster for element access"
    ],
    "incorrect": [
      "Don't know the size in advance",
      "Need to add and remove elements frequently",
      "Want built-in search and sort methods",
      "Need type safety with generics"
    ],
    "feedback": "Arrays are actually slightly faster for element access due to less overhead. Valid reasons to choose ArrayList include unknown size, frequent modifications, built-in utility methods, and better type safety with generics."
  },
  {
    "question": "What happens when you iterate through a HashMap using keySet()?",
    "correct": [
      "You get all keys, but order is not guaranteed"
    ],
    "incorrect": [
      "You get keys in alphabetical order",
      "You get keys in insertion order",
      "You get key-value pairs together",
      "You get only keys that have non-null values"
    ],
    "feedback": "keySet() returns all keys in an unpredictable order - HashMap doesn't maintain insertion order or sort automatically. You only get keys (not values together), and all keys are returned regardless of their values."
  },
  {
    "question": "Which collection types allow null elements?",
    "correct": [
      "ArrayList allows null elements",
      "HashMap allows null keys and values"
    ],
    "incorrect": [
      "HashSet does not allow null elements",
      "LinkedList does not allow null elements",
      "Collections never allow null"
    ],
    "feedback": "ArrayList, LinkedList, HashMap, and HashSet all allow null - they are reference types. The main exception is TreeSet/TreeMap which may throw NullPointerException during sorting. Properly handling null is an important part of working with collections."
  },
  {
    "question": "Why must you check for null when using HashMap.get()?",
    "correct": [
      "get() returns null when the key doesn't exist"
    ],
    "incorrect": [
      "All HashMap values are null by default",
      "HashMap automatically deletes entries that return null",
      "Null checking is only needed for primitive types",
      "The compiler requires null checks for all HashMap operations"
    ],
    "feedback": "HashMap.get() returns null when a key isn't found, so you must check before using the result to avoid NullPointerException. Values aren't null by default, entries aren't auto-deleted, null checking is needed for objects (not just primitives), and the compiler doesn't force these checks."
  },
  {
    "question": "What does ArrayList.clear() do?",
    "correct": [
      "Removes all elements, resulting in size of 0"
    ],
    "incorrect": [
      "Sets all elements to null but keeps the size",
      "Removes only duplicate elements",
      "Resets to initial capacity but keeps elements",
      "Deletes the ArrayList object entirely"
    ],
    "feedback": "clear() removes all elements, making the list empty with size 0. It doesn't set elements to null while keeping size, doesn't remove just duplicates, doesn't affect capacity settings, and doesn't delete the ArrayList object - you can still add elements afterward."
  },
  {
    "question": "Which statements about enhanced for loops with collections are true?",
    "correct": [
      "Cannot modify the collection while iterating",
      "Don't provide access to index positions"
    ],
    "incorrect": [
      "Only work with ArrayList, not other collections",
      "Are slower than traditional for loops",
      "Require the collection to be sorted first"
    ],
    "feedback": "Enhanced for loops (for-each) don't allow safe modification during iteration and don't provide indices. However, they work with all Collection types, have similar performance to traditional loops, and don't require sorting."
  },
  {
    "question": "What is the purpose of generic types in collections?",
    "correct": [
      "Provide compile-time type safety to prevent wrong data types"
    ],
    "incorrect": [
      "Make collections run faster at runtime",
      "Allow collections to store primitives directly",
      "Enable automatic sorting of elements",
      "Reduce memory usage of collections"
    ],
    "feedback": "Generics provide type safety by catching type mismatches at compile time. They don't improve runtime speed, still require wrapper classes for primitives, don't enable automatic sorting, and don't reduce memory usage - they're about correctness, not performance."
  }
]