[
  {
    "question": "Which comparison operators correctly check if a customer's age qualifies them to drink alcohol (21 or older)?",
    "correct": [
      "if (customerAge >= 21)",
      "if (customerAge > 20)"
    ],
    "incorrect": [
      "if (Math.greater(customerAge, 21))",
      "if (customerAge.compareTo(21) >= 0)",
      "if (customerAge => 21)"
    ],
    "feedback": "To check if someone is 21 or older, use >= 21 or > 20 (both include 21 and above). Java doesn't have a Math.greater() method. The compareTo() method is for objects like String or Integer, not primitive int. The => operator doesn't exist in Java (that's from other languages like JavaScript arrow functions)."
  },
  {
    "question": "What happens when you use && (AND) in this condition?\n\nif (hasID && customerAge >= 21)",
    "correct": [
      "Both conditions must be true for the code block to execute"
    ],
    "incorrect": [
      "Either condition can be true for the code block to execute",
      "The conditions are checked one at a time in separate if statements",
      "It's the same as using two nested if statements",
      "Java will check customerAge first because it's a comparison"
    ],
    "feedback": "The && operator requires BOTH conditions to be true. If you want either condition to work, use || (OR). While && does create short-circuit evaluation (like nested ifs in behavior), it's a single condition, not separate statements. Java evaluates left to right, not based on operation type."
  },
  {
    "question": "Which statements correctly create and access an array element?",
    "correct": [
      "String[] drinks = {\"Beer\", \"Wine\"}; System.out.println(drinks[0]);",
      "int[] prices = new int[5]; prices[2] = 10;"
    ],
    "incorrect": [
      "String[] drinks = {\"Beer\", \"Wine\"}; System.out.println(drinks[1st]);",
      "int[] prices = new int[5]; prices[5] = 10;",
      "String[] drinks = {\"Beer\", \"Wine\"}; System.out.println(drinks.get(0));"
    ],
    "feedback": "Array indices must be integers (0, 1, 2...), not ordinals like '1st'. Arrays with size 5 have valid indices 0-4, so index 5 is out of bounds. Arrays use bracket notation drinks[0], not .get(0) which is for ArrayList collections."
  },
  {
    "question": "What is the difference between = and == in Java?",
    "correct": [
      "= assigns a value, == compares values"
    ],
    "incorrect": [
      "= compares values, == assigns a value",
      "They are the same thing",
      "= is for numbers, == is for strings",
      "= is faster than =="
    ],
    "feedback": "The single = is the assignment operator (stores a value in a variable), while == is the comparison operator (tests if two values are equal). This is a fundamental distinction in Java. Both can be used with any data type when appropriate, and performance differences are negligible."
  },
  {
    "question": "In an if-else-if chain, what happens when the first condition is true?",
    "correct": [
      "The first code block executes and all remaining conditions are skipped"
    ],
    "incorrect": [
      "All conditions are still checked but only the first code block executes",
      "All code blocks that have true conditions will execute",
      "Java throws an error because multiple conditions could be true",
      "The conditions are evaluated in parallel"
    ],
    "feedback": "In an if-else-if chain, conditions are evaluated sequentially from top to bottom. As soon as one condition is true, its code block executes and Java skips all remaining conditions entirely. This is why order matters in if-else-if chains."
  },
  {
    "question": "Which for loop syntax is correct for counting from 1 to 10?",
    "correct": [
      "for (int i = 1; i <= 10; i++)"
    ],
    "incorrect": [
      "for (int i = 1; i < 10; i++)",
      "for (i = 1; i <= 10; i++)",
      "for (int i = 1; i <= 10; i+1)",
      "for (int i = 0; i <= 10; i++)"
    ],
    "feedback": "To count 1 to 10 inclusive, use i <= 10. Using i < 10 stops at 9. You must declare the variable type (int i) in the initialization. Use i++ not i+1 for incrementing. Starting at 0 would count 0 to 10 (11 numbers total)."
  },
  {
    "question": "What does array.length return?",
    "correct": [
      "The number of elements in the array"
    ],
    "incorrect": [
      "The highest valid index in the array",
      "The size in bytes of the array",
      "The last element in the array",
      "A method to get array information"
    ],
    "feedback": "array.length returns the count of elements. For an array of size 5, length returns 5, but the highest valid index is 4 (since indexing starts at 0). It's a property, not a method, so no parentheses are used. It doesn't return memory size or array contents."
  },
  {
    "question": "Which condition correctly checks if it's happy hour (5 PM to 7 PM, hours 17-19)?",
    "correct": [
      "if (hour >= 17 && hour <= 19)"
    ],
    "incorrect": [
      "if (hour >= 17 || hour <= 19)",
      "if (hour == 17 && hour == 18 && hour == 19)",
      "if (hour >= 17 && hour < 19)",
      "if (hour.between(17, 19))"
    ],
    "feedback": "Use && for a range check - the hour must be both >= 17 AND <= 19. Using || would include almost all hours (anything ≤19 OR ≥17). You can't have hour equal to multiple values simultaneously. Using < 19 excludes 7 PM. Java doesn't have a between() method for primitives."
  },
  {
    "question": "What happens if you try to access an array element beyond its bounds?",
    "correct": [
      "Java throws an ArrayIndexOutOfBoundsException"
    ],
    "incorrect": [
      "Java returns null",
      "Java returns 0 or empty string",
      "Java automatically expands the array",
      "The program continues with undefined behavior"
    ],
    "feedback": "Java throws an ArrayIndexOutOfBoundsException at runtime when you access an invalid index. Java doesn't return default values, automatically resize arrays, or allow undefined behavior like some other languages. This helps catch programming errors early."
  },
  {
    "question": "Which while loop will execute exactly 5 times?",
    "correct": [
      "int i = 0; while (i < 5) { System.out.println(i); i++; }"
    ],
    "incorrect": [
      "int i = 0; while (i <= 5) { System.out.println(i); i++; }",
      "int i = 1; while (i < 5) { System.out.println(i); i++; }",
      "int i = 0; while (i < 5) { System.out.println(i); }",
      "int i = 5; while (i > 0) { System.out.println(i); i++; }"
    ],
    "feedback": "Starting at 0 and using i < 5 executes for i = 0,1,2,3,4 (5 times). Using i <= 5 executes 6 times. Starting at 1 with i < 5 executes 4 times. Forgetting i++ creates an infinite loop. Starting at 5 and incrementing moves away from the condition."
  },
  {
    "question": "What's wrong with this array declaration?\n\nint[] numbers = {1, 2, 3,};",
    "correct": [
      "Nothing - trailing commas are allowed in array initialization"
    ],
    "incorrect": [
      "You can't have a comma after the last element",
      "Arrays must have at least 4 elements",
      "You need to specify the array size",
      "The syntax should use parentheses instead of braces"
    ],
    "feedback": "Java allows trailing commas in array initialization - this makes it easier to add elements later and is perfectly valid syntax. Array size is determined automatically from the number of elements provided. Braces {} are correct for initialization, not parentheses."
  },
  {
    "question": "Which operator should you use to check if a customer is NOT a regular?",
    "correct": [
      "if (!isRegular)",
      "if (isRegular == false)"
    ],
    "incorrect": [
      "if (isRegular != true)",
      "if (not isRegular)",
      "if (~isRegular)"
    ],
    "feedback": "Use the logical NOT operator (!) or compare with == false. While != true works logically, it's unnecessarily verbose compared to !isRegular. Java doesn't have a 'not' keyword like Python. The ~ operator is for bitwise NOT, not logical NOT."
  },
  {
    "question": "In this code, what value will be printed?\n\nint[] nums = {10, 20, 30};\nSystem.out.println(nums.length - 1);",
    "correct": [
      "2"
    ],
    "incorrect": [
      "3",
      "30",
      "29",
      "The last element of the array"
    ],
    "feedback": "nums.length returns 3 (the count of elements), so nums.length - 1 equals 2. This formula gives you the index of the last element, but prints the index number (2), not the element value (30). This pattern is commonly used to access the last array element."
  },
  {
    "question": "Which statements about else if are true?",
    "correct": [
      "You can have multiple else if statements after an if",
      "The else block is optional at the end"
    ],
    "incorrect": [
      "You must always have an else block",
      "You can only have one else if per if statement",
      "else if conditions are checked even after one is true"
    ],
    "feedback": "You can chain multiple else if statements, and the final else is optional. If no conditions match and there's no else, nothing executes. Once any condition in the chain is true, all remaining conditions are skipped - they're not all checked."
  },
  {
    "question": "What's the difference between i++ and ++i in a for loop?",
    "correct": [
      "In a typical for loop, there's no practical difference"
    ],
    "incorrect": [
      "i++ increments after the loop body, ++i increments before",
      "++i is faster than i++",
      "i++ can only be used in for loops",
      "++i increments by 2, i++ increments by 1"
    ],
    "feedback": "In a for loop's increment section, both i++ and ++i have the same practical effect - they increment i by 1 after each iteration. The difference (post vs pre-increment) only matters when you use the return value of the expression, which doesn't happen in typical for loop increment sections."
  },
  {
    "question": "Which correctly demonstrates the || (OR) operator?",
    "correct": [
      "if (isWeekend || isHoliday) { // extended hours }"
    ],
    "incorrect": [
      "if (isWeekend | isHoliday) { // extended hours }",
      "if (isWeekend OR isHoliday) { // extended hours }",
      "if (isWeekend && isHoliday) { // extended hours }",
      "if (isWeekend + isHoliday) { // extended hours }"
    ],
    "feedback": "The logical OR operator in Java is || (double pipe). Single | is bitwise OR. Java doesn't have an 'OR' keyword. The && operator is AND, not OR. Using + would attempt arithmetic addition, not logical OR."
  },
  {
    "question": "What will this code output?\n\nboolean hasID = true;\nif (hasID) {\n    System.out.println(\"Approved\");\n}\nSystem.out.println(\"Done\");",
    "correct": [
      "Approved\nDone"
    ],
    "incorrect": [
      "Approved",
      "Done",
      "true\nDone",
      "Nothing will print"
    ],
    "feedback": "Since hasID is true, the if condition passes and \"Approved\" prints. The second println(\"Done\") is outside the if block, so it always executes regardless of the condition. Both statements will print on separate lines."
  },
  {
    "question": "Which array access pattern avoids index out of bounds errors?",
    "correct": [
      "for (int i = 0; i < array.length; i++) { use array[i]; }"
    ],
    "incorrect": [
      "for (int i = 1; i <= array.length; i++) { use array[i]; }",
      "for (int i = 0; i <= array.length; i++) { use array[i]; }",
      "for (int i = 0; i < array.size(); i++) { use array[i]; }",
      "Always check if (i < array.length) before each access"
    ],
    "feedback": "Use i < array.length starting from 0. Starting from 1 or using <= goes out of bounds. Arrays don't have a size() method (that's for Collections). While checking bounds before access works, the proper loop structure eliminates the need for extra checks."
  },
  {
    "question": "In this code, how many times will \"Hello\" be printed?\n\nfor (int i = 2; i <= 6; i++) {\n    System.out.println(\"Hello\");\n}",
    "correct": [
      "5"
    ],
    "incorrect": [
      "4",
      "6",
      "3",
      "Infinite times"
    ],
    "feedback": "The loop runs for i = 2, 3, 4, 5, 6 (five values total). Count: 2≤6✓, 3≤6✓, 4≤6✓, 5≤6✓, 6≤6✓, 7≤6✗. So \"Hello\" prints 5 times. The loop terminates when i becomes 7."
  },
  {
    "question": "Which condition checks if a number is between 10 and 20 (inclusive)?",
    "correct": [
      "if (number >= 10 && number <= 20)"
    ],
    "incorrect": [
      "if (number > 10 && number < 20)",
      "if (number >= 10 || number <= 20)",
      "if (10 <= number <= 20)",
      "if (number.between(10, 20))"
    ],
    "feedback": "Use >= and <= for inclusive bounds with &&. Using > and < excludes the endpoints. Using || would include almost all numbers. Java doesn't support chained comparisons like 10 <= number <= 20. There's no between() method for primitives."
  },
  {
    "question": "What's the correct way to create an empty array that can hold 10 integers?",
    "correct": [
      "int[] numbers = new int[10];"
    ],
    "incorrect": [
      "int[] numbers = new int{10};",
      "int[10] numbers = new int[];",
      "int[] numbers = new Array(10);",
      "int[] numbers = {10};"
    ],
    "feedback": "Use new int[10] to create an empty array of size 10. Braces {} are for initialization with values, not size. The size goes in brackets after the type, not before the variable name. Java doesn't have an Array constructor like JavaScript. {10} creates an array with one element (the value 10)."
  },
  {
    "question": "Which statement about array indices is true?",
    "correct": [
      "Array indices always start at 0"
    ],
    "incorrect": [
      "Array indices start at 1",
      "You can choose the starting index when creating an array",
      "String arrays start at 1, numeric arrays start at 0",
      "The starting index depends on the array size"
    ],
    "feedback": "In Java, all arrays use zero-based indexing regardless of type or size. The first element is always at index 0, the second at index 1, etc. This is different from some other languages that start at 1, but in Java it's always 0."
  },
  {
    "question": "What happens in this while loop?\n\nint count = 5;\nwhile (count > 0) {\n    System.out.println(count);\n    count--;\n}",
    "correct": [
      "Prints 5, 4, 3, 2, 1 and then stops"
    ],
    "incorrect": [
      "Prints 5, 4, 3, 2, 1, 0 and then stops",
      "Runs forever because count never reaches 0",
      "Prints nothing because 5 > 0 is false",
      "Throws an error because count goes negative"
    ],
    "feedback": "The loop prints count (5,4,3,2,1), decrements it, and checks the condition. When count becomes 0, the condition 0 > 0 is false, so the loop stops. It doesn't print 0 because the condition is checked before entering the loop body each time."
  },
  {
    "question": "Which loop structure is best for processing every element in an array?",
    "correct": [
      "for (int i = 0; i < array.length; i++)"
    ],
    "incorrect": [
      "while (true) with manual index tracking",
      "for (int i = 1; i <= array.length; i++)",
      "do-while loop",
      "for (int i = array.length; i > 0; i--)"
    ],
    "feedback": "The standard for loop with i < array.length is the most common and clear pattern. Starting at 1 or using <= causes index errors. while(true) requires manual bounds checking and is error-prone. Processing backwards works but is unnecessary unless order matters."
  },
  {
    "question": "What does this expression evaluate to when x = 15?\n\n(x >= 10 && x <= 20)",
    "correct": [
      "true"
    ],
    "incorrect": [
      "false",
      "15",
      "1",
      "The expression is invalid"
    ],
    "feedback": "With x = 15: (15 >= 10) is true AND (15 <= 20) is true. Since both conditions are true, the && operator returns true. Boolean expressions evaluate to true or false, not to numbers like 15 or 1."
  },
  {
    "question": "Which array initialization syntax is valid in Java?",
    "correct": [
      "String[] names = {\"Alice\", \"Bob\"};",
      "int[] numbers = new int[]{1, 2, 3};"
    ],
    "incorrect": [
      "String[] names = [\"Alice\", \"Bob\"];",
      "int[] numbers = (1, 2, 3);",
      "String names[] = new String[]{\"Alice\", \"Bob\"};"
    ],
    "feedback": "Use curly braces {} for array literals, optionally with 'new type[]' prefix. Square brackets [] are for indexing, not initialization. Parentheses () don't work for arrays. While 'String names[]' is technically valid (C-style), the preferred Java style is 'String[] names'."
  },
  {
    "question": "In an if-else statement, when does the else block execute?",
    "correct": [
      "When the if condition is false"
    ],
    "incorrect": [
      "When the if condition is true",
      "Always, after the if block",
      "Only if there's an error in the if block",
      "When both if and else conditions are true"
    ],
    "feedback": "The else block executes only when the if condition evaluates to false. It's an alternative path - either the if block runs OR the else block runs, never both. There are no separate conditions for else blocks."
  },
  {
    "question": "What's the maximum valid index for this array?\n\nchar[] grades = {'A', 'B', 'C', 'D', 'F'};",
    "correct": [
      "4"
    ],
    "incorrect": [
      "5",
      "3",
      "F",
      "grades.length"
    ],
    "feedback": "The array has 5 elements with indices 0,1,2,3,4. The maximum valid index is always array.length - 1, which is 5 - 1 = 4. Index 5 would be out of bounds. 'F' is the value at index 4, not an index itself."
  },
  {
    "question": "Which comparison correctly checks if two strings are equal?",
    "correct": [
      "if (name1.equals(name2))"
    ],
    "incorrect": [
      "if (name1 == name2)",
      "if (name1 = name2)",
      "if (name1.compareTo(name2))",
      "if (String.equals(name1, name2))"
    ],
    "feedback": "Use .equals() method for string content comparison. The == operator compares object references, not content. Single = is assignment. compareTo() returns an integer, not a boolean. There's no static String.equals() method - equals() is called on one of the string objects."
  },
  {
    "question": "What will this nested condition output when age = 25 and hasID = false?\n\nif (age >= 21) {\n    if (hasID) {\n        System.out.println(\"Approved\");\n    } else {\n        System.out.println(\"Need ID\");\n    }\n}",
    "correct": [
      "Need ID"
    ],
    "incorrect": [
      "Approved",
      "Nothing will print",
      "Both \"Approved\" and \"Need ID\"",
      "An error will occur"
    ],
    "feedback": "Since age >= 21 is true (25 >= 21), we enter the outer if. Inside, hasID is false, so we go to the else block and print \"Need ID\". Nested conditions work from outside to inside."
  }
]