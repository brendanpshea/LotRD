[
  {
    "question": "What is a lambda expression in Java?",
    "correct": [
      "A compact, unnamed function that can be passed around like data"
    ],
    "incorrect": [
      "A new type of for loop introduced in Java 8",
      "A special class that must extend the Lambda superclass",
      "A method that always returns a boolean value",
      "A replacement for all if-else statements"
    ],
    "feedback": "Lambda expressions are compact, unnamed functions that can be passed around like data. They're not loops, classes, or if-else replacements. They're anonymous functions - methods without names that you can use inline in your code."
  },
  {
    "question": "Which of the following show correct basic lambda syntax?",
    "correct": [
      "x -> x * 2",
      "(int depth) -> depth > 100"
    ],
    "incorrect": [
      "x => x * 2",
      "lambda x: x * 2",
      "x -> return x * 2;"
    ],
    "feedback": "Correct lambda syntax uses the arrow operator (->) made with a dash and greater-than symbol. The incorrect options use => (from JavaScript/C#), : (from Python), or incorrectly include 'return' with the simplified syntax."
  },
  {
    "question": "What are the main advantages of using streams over traditional loops?",
    "correct": [
      "Clearer intent - the code reads more like what you want to accomplish",
      "Less boilerplate - no manual list creation or explicit loop syntax",
      "Fewer bugs - less code means fewer places to make mistakes"
    ],
    "incorrect": [
      "Streams are always faster than loops in execution time",
      "Streams can modify the original collection while loops cannot"
    ],
    "feedback": "The main advantages of streams are clearer intent (code reads like what you want), less boilerplate code, and fewer opportunities for bugs. Streams aren't necessarily faster in execution, and they never modify the original collection - that's actually a feature, not a limitation."
  },
  {
    "question": "Which statements correctly describe how to create and use streams?",
    "correct": [
      "Call .stream() on an ArrayList to create a stream from it",
      "Streams don't store data - they just process it",
      "Streams never modify the source collection",
      "You need a terminal operation like forEach() to actually execute the stream"
    ],
    "incorrect": [
      "Streams permanently replace the ArrayList once created"
    ],
    "feedback": "All four correct statements are true: call .stream() to create streams, they process but don't store data, they never modify the source, and they're lazy (needing terminal operations to execute). Streams don't replace ArrayLists - they work with them."
  },
  {
    "question": "Which statements correctly describe the forEach() operation?",
    "correct": [
      "It is a terminal operation that ends the stream",
      "It performs an action on each element",
      "It takes a Consumer lambda (accepts a value but returns nothing)",
      "It's similar to an enhanced for loop",
      "It produces side effects like printing rather than returning values"
    ],
    "feedback": "All five statements correctly describe forEach(): it's a terminal operation that ends the stream, performs actions on each element, takes a Consumer lambda (no return value), works like an enhanced for loop, and produces side effects rather than returning values."
  },
  {
    "question": "What does the filter() operation do in a stream?",
    "correct": [
      "Keeps only elements where the predicate returns true"
    ],
    "incorrect": [
      "Transforms each element into a new type",
      "Sorts the elements in ascending order",
      "Counts how many elements match a condition",
      "Removes the stream and returns an ArrayList"
    ],
    "feedback": "filter() keeps only elements where the predicate returns true - like a net catching certain items. It doesn't transform elements (that's map), sort them (that's sorted), count them (that's count), or return ArrayLists (that's collect)."
  },
  {
    "question": "Which statements about the map() operation are correct?",
    "correct": [
      "map() transforms each element into something else",
      "map() takes a Function that converts input to output"
    ],
    "incorrect": [
      "map() selects which elements to keep based on a condition",
      "map() always returns boolean values",
      "map() can only work with String data types"
    ],
    "feedback": "map() transforms elements and takes a Function that converts input to output. It doesn't select elements (that's filter), doesn't return booleans (that's Predicate/filter), and works with any data type, not just Strings."
  },
  {
    "question": "What are the correct ways to complete this stream operation: fleet.stream().filter(ship -> ship.getSpeed() > 20).__________",
    "correct": [
      "forEach(ship -> System.out.println(ship.getName()))",
      "collect(Collectors.toList())",
      "count()"
    ],
    "incorrect": [
      "getResults()",
      "toArrayList()"
    ],
    "feedback": "After filter(), you need a terminal operation to execute the stream: forEach() performs actions, collect() gathers results into a list, and count() returns the number of elements. getResults() and toArrayList() are not real stream methods."
  },
  {
    "question": "Which of the following correctly identify differences between filter() and map()?",
    "correct": [
      "filter() selects items while map() transforms items",
      "filter() returns true/false for each element while map() returns a new value",
      "filter() keeps or removes elements while map() changes what the elements are",
      "filter() uses a Predicate while map() uses a Function"
    ],
    "incorrect": [
      "filter() is a terminal operation while map() is intermediate"
    ],
    "feedback": "All four correct statements highlight the key difference: filter() selects which items to keep (using Predicate), while map() transforms items into something else (using Function). Both are intermediate operations, not one terminal and one intermediate."
  },
  {
    "question": "Which characteristics describe traditional loop-based approaches compared to streams?",
    "correct": [
      "Require creating empty ArrayLists manually",
      "Need explicit for or for-each loop syntax",
      "Specify how to do something step-by-step (imperative style)",
      "Often involve more boilerplate code for simple tasks",
      "Can be more error-prone due to manual list management"
    ],
    "feedback": "All five statements correctly describe traditional loops: they require manual ArrayList creation, explicit loop syntax, follow an imperative (step-by-step) style, involve more boilerplate code, and can be more error-prone. Streams address all these issues with a declarative approach."
  },
  {
    "question": "What is a functional interface in Java?",
    "correct": [
      "An interface with exactly one abstract method"
    ],
    "incorrect": [
      "Any interface that uses the @Functional annotation",
      "An interface that can only be used with functions, not methods",
      "An interface with multiple methods that return the same type",
      "A special class that implements lambda expressions"
    ],
    "feedback": "A functional interface must have exactly one abstract method - this is the key requirement that allows lambdas to work. The @Functional annotation is optional, it's still an interface (not limited to functions), doesn't require multiple methods of the same type, and isn't a class."
  },
  {
    "question": "Which statements correctly describe Predicate<T> and Function<T, R>?",
    "correct": [
      "Predicate<T> tests whether something meets a condition",
      "Predicate<T> has a test() method that returns boolean"
    ],
    "incorrect": [
      "Function<T, R> returns a boolean for yes/no questions",
      "Predicate<T> transforms input into output of a different type",
      "Both Predicate and Function are concrete classes, not interfaces"
    ],
    "feedback": "Predicate<T> tests conditions and has a test() method returning boolean. Function<T, R> transforms data, not Predicate. Predicate returns boolean, not Function. Neither are concrete classes - they're interfaces."
  },
  {
    "question": "What does the collect(Collectors.toList()) operation do?",
    "correct": [
      "Gathers stream results into a new ArrayList",
      "Acts as a terminal operation that ends the stream",
      "Returns a List that you can use elsewhere in your program"
    ],
    "incorrect": [
      "Prints each element to the console",
      "Filters the stream to remove duplicates"
    ],
    "feedback": "collect(Collectors.toList()) gathers stream results into a new ArrayList, acts as a terminal operation that ends the stream, and returns a List you can use later. It doesn't print elements (that's forEach) or filter duplicates (that's distinct)."
  },
  {
    "question": "Identify all the intermediate operations in Java streams:",
    "correct": [
      "filter()",
      "map()",
      "sorted()",
      "limit()"
    ],
    "incorrect": [
      "collect()"
    ],
    "feedback": "filter(), map(), sorted(), and limit() are all intermediate operations that return a new stream and can be chained together. collect() is a terminal operation that ends the stream and produces final results."
  },
  {
    "question": "Which of the following are terminal operations?",
    "correct": [
      "forEach()",
      "collect()",
      "count()",
      "anyMatch()",
      "findFirst()"
    ],
    "feedback": "All five are terminal operations that end the stream and produce results: forEach() performs actions, collect() gathers data, count() returns the total number, anyMatch() tests if any match, and findFirst() returns the first element. Once called, the stream is consumed and cannot be reused."
  },
  {
    "question": "What does the count() operation return?",
    "correct": [
      "A long (integer) indicating how many elements are in the stream"
    ],
    "incorrect": [
      "A List containing all the counted elements",
      "A boolean indicating if any elements exist",
      "An array of integers representing each element's position",
      "An Optional<Integer> that might be empty"
    ],
    "feedback": "count() returns a long (integer type) indicating how many elements are in the stream. It doesn't return a List (that's collect), a boolean (that's anyMatch/allMatch), an array of positions, or an Optional - just a simple number."
  },
  {
    "question": "Which statements about chaining stream operations are true?",
    "correct": [
      "You can chain multiple filter() operations to build complex conditions",
      "Operations are performed in the order they are written"
    ],
    "incorrect": [
      "You can only have one intermediate operation before a terminal operation",
      "Chaining operations creates multiple copies of the collection in memory",
      "Terminal operations can be chained together with intermediate operations"
    ],
    "feedback": "You can chain multiple filter() operations for complex conditions, and operations execute in the order written. However, you can have many intermediate operations before a terminal one, chaining doesn't create multiple copies in memory (streams are lazy), and terminal operations cannot be chained with intermediate ones."
  },
  {
    "question": "What do anyMatch(), allMatch(), and noneMatch() operations return?",
    "correct": [
      "A boolean indicating whether the condition is met",
      "They are terminal operations",
      "They test conditions across stream elements"
    ],
    "incorrect": [
      "A List of elements that matched the condition",
      "An integer count of matching elements"
    ],
    "feedback": "anyMatch(), allMatch(), and noneMatch() all return boolean values, are terminal operations, and test conditions across elements. They don't return Lists of matching elements (that would be filter + collect) or integer counts (that would be count)."
  },
  {
    "question": "Which operations would help you find the fastest ship in a fleet?",
    "correct": [
      "mapToInt(ship -> ship.getSpeed())",
      "max()",
      "sorted(Comparator.comparing(Ship::getSpeed).reversed())",
      "limit(1)"
    ],
    "incorrect": [
      "filter(ship -> ship.getSpeed())"
    ],
    "feedback": "Multiple approaches work: mapToInt() + max() converts to speeds and finds the maximum; sorted() + reversed() + limit(1) sorts and takes the fastest. The incorrect option filter(ship -> ship.getSpeed()) is wrong because filter needs a boolean condition, not just a value extraction."
  },
  {
    "question": "Which statements about numeric streams are correct?",
    "correct": [
      "mapToInt() creates an IntStream with numeric operations",
      "sum() adds all numbers in the stream",
      "max() and min() return Optional values because the stream might be empty",
      "average() calculates the mean and returns OptionalDouble",
      "You use these for calculations like totals, averages, and extremes"
    ],
    "feedback": "All five statements are correct: mapToInt() creates IntStream with numeric operations, sum() adds values, max()/min() return Optional because streams might be empty, average() returns OptionalDouble, and these are used for calculations. Optional types handle the case when there's no data to calculate from."
  },
  {
    "question": "What does the sorted() operation do?",
    "correct": [
      "Arranges stream elements in order"
    ],
    "incorrect": [
      "Removes duplicate elements from the stream",
      "Counts how many elements are in the stream",
      "Filters elements based on their natural ordering",
      "Automatically collects results into a sorted List"
    ],
    "feedback": "sorted() arranges stream elements in order and is an intermediate operation. It doesn't remove duplicates (that's distinct), count elements (that's count), filter based on ordering, or automatically collect results into a List (you need collect() for that)."
  },
  {
    "question": "What do limit() and skip() operations do?",
    "correct": [
      "limit(n) keeps only the first n elements",
      "skip(n) discards the first n elements"
    ],
    "incorrect": [
      "limit(n) removes the first n elements",
      "skip(n) keeps only the first n elements",
      "Both are terminal operations that end the stream"
    ],
    "feedback": "limit(n) keeps the first n elements, skip(n) discards the first n elements, and both are intermediate operations (not terminal). The incorrect options have these reversed - be careful not to confuse them!"
  },
  {
    "question": "Identify the common mistakes when working with streams:",
    "correct": [
      "Forgetting to add a terminal operation, so the stream never executes",
      "Trying to reuse a stream after it's already been consumed",
      "Using limit() before sorted() and getting wrong results"
    ],
    "incorrect": [
      "Using too many intermediate operations in a chain",
      "Creating streams from ArrayList instead of arrays"
    ],
    "feedback": "Common mistakes include: forgetting terminal operations (streams are lazy and won't execute), trying to reuse streams after they're consumed (streams are single-use), and wrong operation order like limit before sort. Having many intermediate operations is fine, and streams work with ArrayLists perfectly well."
  },
  {
    "question": "When finding the top 3 fastest ships, which statements about operation ordering are correct?",
    "correct": [
      "sorted() should come before limit(3) in the pipeline",
      "Using limit(3) before sorted() will give incorrect results",
      "reversed() can be chained with Comparator to sort from highest to lowest",
      "A terminal operation is needed at the end to execute the stream"
    ],
    "incorrect": [
      "limit(3) should come before sorted() for better performance"
    ],
    "feedback": "For finding top results: sorted() must come before limit(3) to get the actual fastest ships. If you limit first, you'll get 3 random ships that are then sorted. reversed() with Comparator sorts highest to lowest, and you need a terminal operation at the end to execute everything."
  },
  {
    "question": "Which statements describe declarative programming with streams?",
    "correct": [
      "You describe what you want, not how to get it",
      "Code reads more like English descriptions of the task",
      "The system figures out the implementation details",
      "It's similar to SQL queries (SELECT, WHERE, ORDER BY)",
      "Focus is on the desired result rather than step-by-step instructions"
    ],
    "feedback": "All five statements correctly describe declarative programming: you state what you want (not how), code reads like English, the system handles implementation, it's similar to SQL queries, and focuses on results rather than steps. This contrasts with imperative programming's step-by-step instructions."
  },
  {
    "question": "What does findFirst() return?",
    "correct": [
      "An Optional containing the first element, or empty if stream is empty"
    ],
    "incorrect": [
      "The first element directly, or null if none exists",
      "A List containing only the first element",
      "A boolean indicating whether a first element exists",
      "An integer representing the index of the first element"
    ],
    "feedback": "findFirst() returns an Optional containing the first element (or empty if the stream is empty). It doesn't return the element directly with null (that would cause NullPointerExceptions), doesn't return a List or boolean, and doesn't return an index. Use .isPresent() to check and .get() to retrieve the value."
  },
  {
    "question": "Which are valid ways to use Comparator.comparing() for sorting?",
    "correct": [
      "Comparator.comparing(ship -> ship.getSpeed())",
      "Comparator.comparing(Ship::getSpeed).reversed()"
    ],
    "incorrect": [
      "Comparator.comparing(ship -> ship.getSpeed() > 20)",
      "Comparator.comparing().reversed(ship -> ship.getSpeed())",
      "Comparator.sortBy(ship -> ship.getSpeed())"
    ],
    "feedback": "Correct syntax: Comparator.comparing(ship -> ship.getSpeed()) or with .reversed() at the end for descending order. Wrong: you can't compare boolean conditions, can't put reversed() before the lambda, and sortBy() isn't a real method (it's comparing())."
  },
  {
    "question": "What happens when you call .stream() on an ArrayList?",
    "correct": [
      "A new stream is created from the collection",
      "The original ArrayList remains unchanged",
      "You get a Stream object that can process the data"
    ],
    "incorrect": [
      "The ArrayList is converted into a stream and can no longer be used as a list",
      "All elements are immediately processed and filtered"
    ],
    "feedback": "Calling .stream() creates a new stream from the collection, leaves the ArrayList unchanged, and gives you a Stream object for processing. It doesn't convert or replace the ArrayList, and it doesn't immediately process elements - streams are lazy and need terminal operations to execute."
  },
  {
    "question": "Which statements correctly explain when to use streams vs traditional loops?",
    "correct": [
      "Use streams for processing collections with multiple operations (filter, map, collect)",
      "Use streams when creating new filtered or transformed collections",
      "Use traditional loops for simple iterations like just printing items",
      "Use traditional loops when you need to modify the original collection in place"
    ],
    "incorrect": [
      "Always use streams because they're faster than loops in all situations"
    ],
    "feedback": "All four correct statements identify when to use each approach. Use streams for complex processing pipelines and creating new collections; use loops for simple iterations and in-place modifications. Streams aren't always faster - choose based on clarity and the task, not performance assumptions."
  },
  {
    "question": "Which statements describe correct characteristics of stream pipelines?",
    "correct": [
      "Collections like ArrayList serve as the data source for streams",
      "Operations like filter, map, and sorted are intermediate operations",
      "Operations like collect, forEach, and count are terminal operations",
      "Data flows through the pipeline like water through pipes",
      "Intermediate operations don't execute until a terminal operation is called"
    ],
    "feedback": "All five statements correctly describe stream pipelines: collections are the data source, filter/map/sorted are intermediate operations, collect/forEach/count are terminal operations, data flows through like water in pipes, and intermediate operations are lazy (don't execute until terminal operation is called)."
  }
]