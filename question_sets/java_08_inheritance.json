[
  {
    "question": "What is the correct syntax to create a subclass in Java?",
    "correct": [
      "public class Child extends Parent { }"
    ],
    "incorrect": [
      "public class Child inherits Parent { }",
      "public class Child implements Parent { }",
      "public class Child : Parent { }",
      "public class Child <- Parent { }"
    ],
    "feedback": "Use the 'extends' keyword to create inheritance in Java. 'inherits' isn't a Java keyword. 'implements' is for interfaces, not classes. The colon syntax is from C#/C++, and <- isn't valid Java syntax."
  },
  {
    "question": "In a subclass constructor, when must you call super()?",
    "correct": [
      "As the first statement in the constructor"
    ],
    "incorrect": [
      "As the last statement in the constructor",
      "Anywhere within the constructor body",
      "Only if the parent class has parameters",
      "It's called automatically, so never explicitly"
    ],
    "feedback": "The super() call must be the very first statement in a subclass constructor. This ensures the parent class is properly initialized before the child class adds its own initialization. If you don't call super() explicitly, Java automatically calls the no-argument super()."
  },
  {
    "question": "What does the @Override annotation do?",
    "correct": [
      "Tells the compiler to verify you're actually overriding a parent method"
    ],
    "incorrect": [
      "Makes the method run faster",
      "Prevents other classes from overriding the method",
      "Automatically calls the parent's version first",
      "Creates a new method signature"
    ],
    "feedback": "The @Override annotation helps catch errors by ensuring the method signature exactly matches a parent method. It doesn't affect performance, doesn't prevent further overriding, and doesn't automatically call super. It's purely a compile-time check for correctness."
  },
  {
    "question": "Which of these is NOT true about method overriding?",
    "correct": [
      "You can change the return type to any type you want"
    ],
    "incorrect": [
      "The method signature must exactly match the parent method",
      "The subclass method can have different implementation",
      "@Override annotation helps catch signature mistakes",
      "The overridden method is called based on the object's runtime type"
    ],
    "feedback": "You cannot change the return type to any type - it must be the same type or a subtype (covariant return). All other statements are true: signature must match exactly, implementation can differ, @Override helps verification, and runtime type determines which method executes."
  },
  {
    "question": "What is polymorphism in Java?",
    "correct": [
      "Using a parent reference to call different implementations in child classes"
    ],
    "incorrect": [
      "Having multiple constructors in a class",
      "Using the same method name with different parameters",
      "Inheriting from multiple parent classes",
      "Creating multiple instances of the same class"
    ],
    "feedback": "Polymorphism allows a single variable (of parent/interface type) to refer to objects of different child types, with the correct overridden method being called at runtime. Multiple constructors is overloading, same method name with different parameters is also overloading, and Java doesn't support multiple inheritance of classes."
  },
  {
    "question": "What will this code output?\n\nExercise e = new Squat(10);\ne.perform();",
    "correct": [
      "The Squat class's perform() method will run"
    ],
    "incorrect": [
      "The Exercise class's perform() method will run",
      "Both Exercise and Squat perform() methods will run",
      "A compilation error will occur",
      "The code will crash at runtime"
    ],
    "feedback": "This demonstrates polymorphism and dynamic method dispatch. Even though the variable 'e' is typed as Exercise, the actual object is a Squat, so Squat's overridden perform() method will execute at runtime. The compiler allows this because perform() exists in Exercise."
  },
  {
    "question": "Which interface declaration is correct?",
    "correct": [
      "public interface Trackable { String name(); int calories(); }"
    ],
    "incorrect": [
      "public interface Trackable { abstract String name(); abstract int calories(); }",
      "public abstract interface Trackable { String name(); int calories(); }",
      "interface Trackable { public String name(); public int calories(); }",
      "public interface Trackable { String name() { }; int calories() { }; }"
    ],
    "feedback": "Interface methods are abstract and public by default, so no need to specify these keywords explicitly. Adding 'abstract' to the interface declaration itself is redundant. Methods in interfaces have no body (no braces with implementation) unless they're default or static methods."
  },
  {
    "question": "Which of these statements about interfaces are correct?",
    "correct": [
      "A class can implement multiple interfaces",
      "Interface methods are abstract by default"
    ],
    "incorrect": [
      "Interfaces can have constructors",
      "You can create instances of interfaces using 'new'",
      "Interfaces can extend classes"
    ],
    "feedback": "Classes can implement multiple interfaces (using comma separation), and interface methods are abstract by default. Interfaces cannot have constructors, cannot be instantiated directly, and cannot extend classes (though they can extend other interfaces)."
  },
  {
    "question": "What's the difference between an abstract class and an interface?",
    "correct": [
      "Abstract classes can have constructors and instance fields, interfaces cannot"
    ],
    "incorrect": [
      "Abstract classes cannot have method implementations",
      "Interfaces can have constructors",
      "You can extend multiple abstract classes",
      "Abstract classes are faster than interfaces"
    ],
    "feedback": "Abstract classes can have constructors, instance fields, and both concrete and abstract methods. Interfaces traditionally have only method signatures (though modern Java allows default methods). You can only extend one class but implement multiple interfaces. Performance differences are negligible."
  },
  {
    "question": "Which method signature correctly overrides this parent method?\n\npublic void perform() { }",
    "correct": [
      "public void perform() { }"
    ],
    "incorrect": [
      "public int perform() { }",
      "public void perform(int reps) { }",
      "protected void perform() { }",
      "public void perform() throws Exception { }"
    ],
    "feedback": "Method overriding requires the exact same signature: same name, same parameters, same return type, and same or more accessible visibility. Changing return type, adding parameters, reducing visibility, or adding checked exceptions breaks the override contract."
  },
  {
    "question": "What happens when you try to instantiate an abstract class?",
    "correct": [
      "Compilation error - cannot instantiate abstract classes"
    ],
    "incorrect": [
      "It creates an instance but you can't call abstract methods",
      "It automatically creates a concrete subclass",
      "Runtime exception is thrown",
      "It works fine if there are no abstract methods"
    ],
    "feedback": "You cannot instantiate abstract classes using 'new' - this is caught at compile time. Even if an abstract class has no abstract methods, it still cannot be instantiated if declared as abstract. You must create concrete subclasses that implement all abstract methods."
  },
  {
    "question": "Which types of members does the 'static' keyword apply to?",
    "correct": [
      "Methods - they belong to the class rather than instances",
      "Fields - they are shared by all instances of the class"
    ],
    "incorrect": [
      "Constructors - they initialize the class itself",
      "Local variables - they persist between method calls",
      "Instance fields to make them unchangeable"
    ],
    "feedback": "Static applies to methods and fields, making them class-level rather than instance-level. Constructors cannot be static (they create instances), local variables cannot be static (they're method-scoped), and static doesn't make things unchangeable (that's final)."
  },
  {
    "question": "What does the 'final' keyword prevent?",
    "correct": [
      "final variables cannot be reassigned",
      "final methods cannot be overridden"
    ],
    "incorrect": [
      "final objects cannot have their internal state changed",
      "final classes can still be extended",
      "final methods cannot be called"
    ],
    "feedback": "The 'final' keyword prevents reassignment for variables, overriding for methods, and extension for classes. However, final object references can still have their internal state modified (the reference is final, not the object's contents). Final classes like String cannot be extended."
  },
  {
    "question": "Which of the following is NOT a valid way to call a parent class method?",
    "correct": [
      "parent.methodName()"
    ],
    "incorrect": [
      "super.methodName()",
      "super() in constructor",
      "Calling inherited methods directly",
      "Using method overriding to replace parent behavior"
    ],
    "feedback": "Java doesn't have a 'parent' keyword - you must use 'super' to explicitly call parent methods. All other options are valid: super.methodName() calls parent methods, super() calls parent constructors, inherited methods can be called directly, and overriding allows replacing parent behavior."
  },
  {
    "question": "What is dynamic method dispatch?",
    "correct": [
      "Java choosing which overridden method to call based on the object's actual type at runtime"
    ],
    "incorrect": [
      "Calling multiple methods with the same name but different parameters",
      "The compiler determining which method to call at compile time",
      "Automatically calling parent methods before child methods",
      "Creating methods that can accept different parameter types"
    ],
    "feedback": "Dynamic method dispatch is Java's mechanism for polymorphism - at runtime, Java looks at the actual object type and calls the appropriate overridden method. This differs from compile-time method resolution and method overloading."
  },
  {
    "question": "In this code, which perform() method will execute?\n\nExercise[] exercises = {new PushUp(), new Squat(5)};\nfor (Exercise e : exercises) { e.perform(); }",
    "correct": [
      "Each object's own overridden perform() method"
    ],
    "incorrect": [
      "Only Exercise's perform() method for both objects",
      "The code won't compile because of type mismatch",
      "PushUp's perform() for both objects",
      "A runtime error will occur"
    ],
    "feedback": "This demonstrates polymorphism in action. Despite all variables being typed as Exercise, each object retains its actual type (PushUp, Squat), so their respective overridden perform() methods will execute. This is the power of dynamic method dispatch."
  },
  {
    "question": "What's the purpose of the instanceof operator?",
    "correct": [
      "To check if an object is an instance of a specific class or implements an interface"
    ],
    "incorrect": [
      "To create a new instance of a class",
      "To compare two objects for equality",
      "To cast an object to a different type",
      "To call a method on multiple object types"
    ],
    "feedback": "The instanceof operator returns true if an object is an instance of the specified class or implements the specified interface. It's commonly used before casting to avoid ClassCastException. It doesn't create objects, compare equality, or perform casting itself."
  },
  {
    "question": "Which cast is safe and which requires a runtime check?",
    "correct": [
      "Upcasting (child to parent) is always safe, downcasting (parent to child) needs runtime check"
    ],
    "incorrect": [
      "Downcasting is always safe, upcasting needs runtime check",
      "Both upcasting and downcasting are always safe",
      "Both upcasting and downcasting always need runtime checks",
      "Casting is determined by the compiler and always safe"
    ],
    "feedback": "Upcasting (treating a child as its parent type) is always safe because every child 'is-a' parent. Downcasting (treating a parent-typed reference as a child) can fail at runtime if the actual object isn't of that child type, so use instanceof first."
  },
  {
    "question": "What does this code demonstrate?\n\nTrackable t = new JumpingJacks(50);\nSystem.out.println(t.calories());",
    "correct": [
      "Programming to an interface and polymorphism"
    ],
    "incorrect": [
      "Method overloading",
      "Constructor chaining",
      "Static method calling",
      "Exception handling"
    ],
    "feedback": "This shows programming to an interface (Trackable) rather than a concrete class. The variable is typed as the interface, but holds a concrete implementation. When calories() is called, the JumpingJacks implementation runs - this is polymorphism in action."
  },
  {
    "question": "Why would you declare a field as 'private final'?",
    "correct": [
      "To create an unchangeable field that's only accessible within the class"
    ],
    "incorrect": [
      "To make the field accessible to subclasses but not other classes",
      "To create a class-wide constant shared by all instances",
      "To allow the field to be modified only once per object",
      "To automatically initialize the field to a default value"
    ],
    "feedback": "The combination of 'private final' creates an encapsulated, immutable field. 'private' restricts access to the class, 'final' prevents reassignment after initialization. For subclass access, you'd use 'protected'. For class-wide constants, add 'static'."
  },
  {
    "question": "What's the difference between method overriding and method overloading?",
    "correct": [
      "Overriding replaces a parent method, overloading creates multiple methods with same name but different parameters"
    ],
    "incorrect": [
      "Overriding creates new methods, overloading replaces parent methods",
      "Overriding works with interfaces, overloading works with classes",
      "Overriding happens at compile time, overloading happens at runtime",
      "They are the same thing with different names"
    ],
    "feedback": "Overriding is providing a new implementation for an inherited method (same signature). Overloading is creating multiple methods with the same name but different parameters in the same class. Overriding enables polymorphism, overloading provides method variants."
  },
  {
    "question": "Which statement about abstract methods is true?",
    "correct": [
      "Abstract methods must be implemented by concrete subclasses"
    ],
    "incorrect": [
      "Abstract methods can have method bodies",
      "Abstract methods are automatically static",
      "Abstract methods cannot be public",
      "Abstract methods are optional to implement"
    ],
    "feedback": "Abstract methods have no body and must be implemented by any concrete (non-abstract) subclass. They can have any visibility modifier, are not static by default, and implementation is mandatory for concrete subclasses - otherwise the subclass must also be declared abstract."
  },
  {
    "question": "What happens if a class implements an interface but doesn't provide all required methods?",
    "correct": [
      "Compilation error - class must implement all interface methods or be declared abstract"
    ],
    "incorrect": [
      "The missing methods get default implementations",
      "Runtime error when trying to call the missing method",
      "The class automatically becomes abstract",
      "Java provides empty implementations for missing methods"
    ],
    "feedback": "Java requires that concrete classes implement all methods from their interfaces. If a class doesn't implement all interface methods, it must be declared abstract, or the compiler will throw an error. Java doesn't provide automatic implementations."
  },
  {
    "question": "Which keywords can be used together to create a class-wide constant?",
    "correct": [
      "public static final",
      "private static final"
    ],
    "incorrect": [
      "void static",
      "static const",
      "final const"
    ],
    "feedback": "Both 'public static final' and 'private static final' create class-wide constants - the difference is visibility. 'static' makes it class-level (shared), 'final' makes it unchangeable. Without 'static', each instance would have its own copy. Java doesn't have a 'const' keyword."
  },
  {
    "question": "In polymorphism, what determines which method gets called?",
    "correct": [
      "The actual object type at runtime, not the variable type"
    ],
    "incorrect": [
      "The variable type declared in the code",
      "The first method found in the inheritance hierarchy",
      "The method with the most specific parameters",
      "The compiler chooses randomly among available methods"
    ],
    "feedback": "Polymorphism uses dynamic method dispatch - Java looks at the actual object type (runtime type) to determine which overridden method to call, not the declared variable type (compile-time type). This allows the same code to work with different object types."
  },
  {
    "question": "Which of these can contain both abstract and concrete methods?",
    "correct": [
      "Abstract classes"
    ],
    "incorrect": [
      "Interfaces (in traditional Java)",
      "Final classes",
      "Static classes",
      "Private classes"
    ],
    "feedback": "Abstract classes can contain both abstract methods (no implementation) and concrete methods (with implementation), plus fields and constructors. Traditional interfaces only had abstract methods (though modern Java allows default methods). Final classes cannot be abstract."
  },
  {
    "question": "What is the main benefit of programming to interfaces rather than concrete classes?",
    "correct": [
      "Code becomes more flexible and can work with multiple implementations"
    ],
    "incorrect": [
      "Programs run significantly faster",
      "Less memory is used",
      "Interfaces prevent runtime errors",
      "Code is easier to debug"
    ],
    "feedback": "Programming to interfaces promotes flexibility - your code can work with any class that implements the interface, making it easier to swap implementations, add new types, and test with mock objects. Performance and memory differences are minimal."
  },
  {
    "question": "What does 'super()' do in a constructor?",
    "correct": [
      "Calls the parent class constructor"
    ],
    "incorrect": [
      "Calls the current class constructor",
      "Creates a new parent object",
      "Copies all parent fields to the child",
      "Makes the constructor more powerful"
    ],
    "feedback": "The super() call invokes the parent class constructor to initialize the parent portion of the object. If you don't call super() explicitly, Java automatically calls the no-argument parent constructor. This ensures proper object initialization in the inheritance hierarchy."
  },
  {
    "question": "Which visibility modifier allows access by subclasses but not by unrelated classes?",
    "correct": [
      "protected"
    ],
    "incorrect": [
      "public",
      "private",
      "package-private (default)",
      "final"
    ],
    "feedback": "The 'protected' modifier allows access by subclasses and classes in the same package, but not by unrelated classes in other packages. 'public' allows access by everyone, 'private' only by the same class, and package-private allows access within the same package but not by subclasses in other packages."
  },
  {
    "question": "What will happen if you try to override a static method in a subclass?",
    "correct": [
      "The subclass method hides the parent method rather than overriding it"
    ],
    "incorrect": [
      "Normal polymorphic override occurs",
      "Compilation error - static methods cannot be overridden",
      "Runtime error when the method is called",
      "Both methods will be called in sequence"
    ],
    "feedback": "Static methods cannot be truly overridden - they are 'hidden' instead. If a subclass defines a static method with the same signature as a parent's static method, the subclass version hides the parent version. No polymorphic behavior occurs; the method called depends on the class name used."
  }
]