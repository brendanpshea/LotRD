[
  {
    "question": "What is a function in programming?",
    "correct": [
      "A reusable block of code that performs a specific task"
    ],
    "incorrect": [
      "A variable that stores multiple values",
      "A type of loop structure",
      "A way to declare arrays",
      "A method for user input"
    ],
    "feedback": "A function is a reusable block of code that performs a specific task. Functions help organize code, reduce repetition, and make programs more maintainable. The incorrect options represent other programming constructs: arrays store multiple values, loops repeat code, array declarations create collections, and input methods get data from users."
  },
  {
    "question": "Which are essential components of a Java function declaration?",
    "correct": [
      "Return type",
      "Function name"
    ],
    "incorrect": [
      "At least one parameter",
      "A loop structure",
      "Global variables"
    ],
    "feedback": "Java functions must have a return type (like int, String, or void) and a function name. Parameters are optional - functions can have zero parameters. Functions don't require loops or global variables. The 'public static' keywords are also required for functions called from main, but the return type and name are the fundamental components."
  },
  {
    "question": "Which Java function declarations are syntactically correct?",
    "correct": [
      "public static double calculateTax(double amount) { return amount * 0.08; }",
      "public static void printWelcome() { System.out.println(\"Hello\"); }",
      "public static String getName(String first, String last) { return first + last; }"
    ],
    "incorrect": [
      "public static return double getPrice() { return 9.99; }",
      "public static void getTotal(double price) { double total = price * 1.08; }"
    ],
    "feedback": "Correct function syntax requires the return type after 'public static', followed by the function name and parameters. The incorrect examples show common errors: placing 'return' before the return type in the declaration, and having a void function that calculates but doesn't return a value (missing return statement for the implied purpose)."
  },
  {
    "question": "What happens when you call a function with the wrong number of parameters?",
    "correct": [
      "Compilation error occurs",
      "The program fails to compile",
      "Java compiler reports missing or extra arguments",
      "Code cannot be turned into bytecode"
    ],
    "incorrect": [
      "The function uses default values"
    ],
    "feedback": "Java requires exact parameter matching when calling functions. If you call a function with the wrong number of arguments, the compiler generates an error and refuses to compile the code. Java doesn't provide default parameter values like some other languages - you must provide exactly the right number of arguments with correct types."
  },
  {
    "question": "What are the characteristics of local variables in functions?",
    "correct": [
      "Exist only during function execution",
      "Cannot be accessed from other functions",
      "Are destroyed when the function ends",
      "Include the function's parameters",
      "Have function scope"
    ],
    "incorrect": [],
    "feedback": "Local variables exist only while their function is running and are destroyed when the function completes. They cannot be accessed from outside their function, which prevents naming conflicts and maintains encapsulation. Parameters are also local variables that receive values when the function is called. This scoping rule is fundamental to function design and program organization."
  },
  {
    "question": "Which String method correctly checks if a customer name contains 'Bob'?",
    "correct": [
      "customerName.contains(\"Bob\")"
    ],
    "incorrect": [
      "customerName.has(\"Bob\")",
      "String.contains(customerName, \"Bob\")",
      "customerName.includes(\"Bob\")",
      "contains(customerName, \"Bob\")"
    ],
    "feedback": "The contains() method is called on a String object and returns true if the string contains the specified substring. Java doesn't have has(), includes(), or global contains() functions. String methods are called on string instances using dot notation, not as static methods of the String class."
  },
  {
    "question": "What are benefits of using functions in programming?",
    "correct": [
      "Code reusability",
      "Better organization"
    ],
    "incorrect": [
      "Automatic performance optimization",
      "Reduced memory usage",
      "Faster compilation times"
    ],
    "feedback": "Functions provide code reusability (write once, use many times) and better program organization by breaking complex problems into manageable pieces. They don't automatically make programs faster, don't inherently use less memory, and don't speed up compilation. The benefits are primarily about code structure, maintenance, and development efficiency."
  },
  {
    "question": "Which function calls will compile successfully?",
    "correct": [
      "calculateTax(25.99) when function expects double",
      "getName(\"Bob\", \"Smith\") when function expects two Strings",
      "isEligible(18) when function expects int"
    ],
    "incorrect": [
      "calculateTax(\"25.99\") when function expects double",
      "getName(25, 30) when function expects two Strings"
    ],
    "feedback": "Function calls compile when argument types match parameter types. Passing a double to a double parameter, two Strings to String parameters, and an int to an int parameter all work correctly. However, passing a String where a double is expected or integers where Strings are expected causes type mismatch compilation errors."
  },
  {
    "question": "What does this function return: public static boolean isExpensive(double price) { return price > 100.0; }?",
    "correct": [
      "true if price is greater than 100",
      "false if price is 100 or less",
      "A boolean value based on the comparison",
      "The result of evaluating price > 100.0"
    ],
    "incorrect": [
      "The actual price value"
    ],
    "feedback": "This function returns a boolean value: true if the price is greater than 100, false otherwise. It evaluates the comparison price > 100.0 and returns that boolean result. The function doesn't return the price itself - it returns a true/false answer about whether the price meets the 'expensive' criteria."
  },
  {
    "question": "When does a return statement execute in a function?",
    "correct": [
      "Immediately exits the function and sends back a value"
    ],
    "incorrect": [
      "Continues executing remaining function code",
      "Stores the value for later use",
      "Only works at the end of functions",
      "Prints the value to the console"
    ],
    "feedback": "The return statement immediately terminates function execution and sends the specified value back to the calling code. No code after the return statement will execute. It doesn't store values, print them, or allow continued execution - it's an immediate exit point that provides a result to the caller."
  },
  {
    "question": "Which Java code correctly combines two String parameters?",
    "correct": [
      "return firstName + \" \" + lastName;",
      "return firstName.concat(\" \").concat(lastName);"
    ],
    "incorrect": [
      "return firstName.add(\" \").add(lastName);",
      "return combine(firstName, \" \", lastName);",
      "return firstName.append(\" \").append(lastName);"
    ],
    "feedback": "Strings can be combined using the + operator or the concat() method. The + operator is most common for simple concatenation. Java Strings don't have add() or append() methods, and there's no built-in combine() function. The concat() method works but requires chaining for multiple concatenations."
  },
  {
    "question": "What are valid approaches for handling invalid function inputs?",
    "correct": [
      "Return special values like -1 or null",
      "Use if statements to check parameters",
      "Provide different behavior for edge cases"
    ],
    "incorrect": [
      "Assume all inputs are always valid",
      "Let the program crash with any invalid input"
    ],
    "feedback": "Good functions validate inputs and handle invalid cases gracefully. Common approaches include returning special values (like -1 for 'not found'), checking parameters with if statements, and providing appropriate behavior for edge cases. Assuming all inputs are valid or allowing crashes makes programs unreliable and user-unfriendly."
  },
  {
    "question": "What happens with this code: public static void calculateTotal(double price) { double total = price * 1.08; }?",
    "correct": [
      "Calculates total but doesn't return it",
      "The calculated value is lost when function ends",
      "Function performs calculation but provides no output",
      "Local variable total is destroyed after execution"
    ],
    "incorrect": [
      "Returns the calculated total to the caller"
    ],
    "feedback": "This void function calculates a total but doesn't return it, so the calculated value is lost when the function ends. The total variable is local and gets destroyed when the function completes. For the calculation to be useful, the function should either return the value or print it - currently it just wastes the computation."
  },
  {
    "question": "Which demonstrates proper boolean function usage?",
    "correct": [
      "if (isValidAge(25)) { processOrder(); }"
    ],
    "incorrect": [
      "boolean result = isValidAge(\"twenty-five\");",
      "int status = isValidAge(25);",
      "String check = isValidAge(25);",
      "isValidAge(25) = true;"
    ],
    "feedback": "Boolean functions are commonly used in if statements for decision making. The correct example calls the function and uses its true/false result directly in a conditional. The incorrect examples show type mismatches (wrong parameter type, wrong variable type for storing result) or invalid syntax (trying to assign to a function call)."
  },
  {
    "question": "What are signs of well-designed functions?",
    "correct": [
      "Performs a single, clear task",
      "Has a descriptive name",
      "Uses meaningful parameter names",
      "Returns appropriate values",
      "Can be easily tested"
    ],
    "incorrect": [],
    "feedback": "Well-designed functions focus on single tasks, have descriptive names that explain their purpose, use meaningful parameter names, return values that are useful to callers, and are structured for easy testing. These principles make functions more maintainable, reusable, and understandable. Functions that try to do too much or have unclear purposes are harder to debug and maintain."
  },
  {
    "question": "Which function header correctly declares multiple parameters?",
    "correct": [
      "public static double calculatePrice(String item, int quantity, double unitPrice)"
    ],
    "incorrect": [
      "public static double calculatePrice(String item; int quantity; double unitPrice)",
      "public static double calculatePrice(item, quantity, unitPrice)",
      "public static double calculatePrice(String, int, double)",
      "public static double calculatePrice(String item int quantity double unitPrice)"
    ],
    "feedback": "Function parameters require both type and name for each parameter, separated by commas. The correct syntax shows each parameter with its data type followed by the parameter name. The incorrect versions use wrong separators (semicolons), missing types, missing names, or missing separators entirely."
  },
  {
    "question": "What error occurs in this function: public static int getValue() { System.out.println(\"Getting value\"); }?",
    "correct": [
      "Missing return statement",
      "Function promises to return int but doesn't"
    ],
    "incorrect": [
      "Wrong parameter list",
      "Incorrect function name",
      "Invalid print statement location"
    ],
    "feedback": "Functions with non-void return types must include a return statement that provides a value of the promised type. This function declares it will return an int but only prints a message, causing a compilation error. Every execution path in a non-void function must return an appropriate value."
  },
  {
    "question": "Which String methods return modified versions of the original string?",
    "correct": [
      "toUpperCase() creates a new uppercase string",
      "substring(0, 3) creates a new string with first 3 characters",
      "trim() creates a new string with whitespace removed"
    ],
    "incorrect": [
      "toUpperCase() modifies the original string",
      "substring() changes the original string permanently"
    ],
    "feedback": "String methods in Java create new strings rather than modifying the original. Methods like toUpperCase(), substring(), and trim() return new String objects with the desired changes. The original string remains unchanged. This immutability is a key characteristic of Java strings that prevents unexpected side effects."
  },
  {
    "question": "What is the purpose of function parameters?",
    "correct": [
      "Receive input values when the function is called",
      "Allow functions to work with different data",
      "Make functions more flexible and reusable",
      "Provide information the function needs to operate"
    ],
    "incorrect": [
      "Store the function's return value"
    ],
    "feedback": "Parameters allow functions to receive input values, making them flexible and reusable with different data. They provide the information functions need to perform their tasks. Parameters don't store return values - they receive input values from function calls. This input mechanism is what makes functions adaptable to different situations."
  },
  {
    "question": "Which statement about variable scope is correct?",
    "correct": [
      "Variables declared inside functions cannot be accessed outside those functions"
    ],
    "incorrect": [
      "All variables can be accessed from anywhere in the program",
      "Function parameters can be used in other functions",
      "Local variables retain their values between function calls",
      "Variables declared in main() are global"
    ],
    "feedback": "Variable scope in Java is function-based: variables declared inside functions (including parameters) exist only within those functions. They cannot be accessed from outside, don't retain values between calls, and are not global even if declared in main(). This encapsulation prevents naming conflicts and maintains proper program structure."
  },
  {
    "question": "What makes functions easier to debug and maintain?",
    "correct": [
      "Each function has a single, clear responsibility",
      "Functions are short enough to understand quickly"
    ],
    "incorrect": [
      "Functions are exactly 10 lines long",
      "All functions return strings",
      "Functions never call other functions"
    ],
    "feedback": "Maintainable functions have single, clear responsibilities and are short enough to understand easily. Arbitrary length limits (like exactly 10 lines) don't ensure quality. Return types should match the function's purpose, not follow a universal pattern. Functions calling other functions is actually a sign of good modular design, allowing complex tasks to be broken into manageable pieces."
  },
  {
    "question": "Which Java code correctly checks if a string starts with a specific prefix?",
    "correct": [
      "fileName.startsWith(\"menu\")",
      "customerName.startsWith(\"Dr.\")"
    ],
    "incorrect": [
      "String.startsWith(fileName, \"menu\")",
      "fileName.beginsWith(\"menu\")",
      "startsWith(fileName, \"menu\")"
    ],
    "feedback": "The startsWith() method is called on String objects using dot notation. It returns true if the string begins with the specified prefix. Java doesn't have a beginsWith() method, doesn't use static String methods for this purpose, and doesn't have global startsWith() functions."
  },
  {
    "question": "What happens when you call a function that requires parameters without providing any?",
    "correct": [
      "Compilation error due to missing arguments",
      "Java compiler reports insufficient parameters",
      "Program fails to compile"
    ],
    "incorrect": [
      "Function uses default values for missing parameters",
      "Function executes with null values"
    ],
    "feedback": "Java requires all function parameters to be provided when calling the function. Missing arguments cause compilation errors because Java doesn't provide default parameter values or automatically use null. The compiler will report exactly how many arguments were expected versus how many were provided."
  },
  {
    "question": "Which represents the best practice for function return values?",
    "correct": [
      "Return values should match the function's stated purpose",
      "Use appropriate data types for the returned information",
      "Consider what the calling code will do with the result"
    ],
    "incorrect": [
      "Always return strings for maximum flexibility",
      "Never return boolean values"
    ],
    "feedback": "Good return value design matches the function's purpose and uses appropriate data types. Consider how calling code will use the result - return booleans for yes/no questions, numbers for calculations, strings for text processing. Don't default to strings for everything, and boolean returns are valuable for decision-making functions."
  },
  {
    "question": "What is the difference between these function calls: calculateTax(price) vs calculateTax(25.99)?",
    "correct": [
      "First uses a variable, second uses a literal value",
      "Both are valid if price contains a double value",
      "First requires price to be declared and initialized",
      "Second directly passes the number 25.99"
    ],
    "incorrect": [
      "Only the second call will compile"
    ],
    "feedback": "Both calls are valid assuming calculateTax() expects a double parameter. The first passes the value stored in the variable 'price' (which must be declared and initialized), while the second passes the literal value 25.99 directly. Variables and literal values can both be used as function arguments as long as their types match the parameter types."
  },
  {
    "question": "Which Java String methods can be chained together effectively?",
    "correct": [
      "name.trim().toUpperCase()",
      "text.substring(0, 5).toLowerCase()",
      "input.replace(\" \", \"\").trim()"
    ],
    "incorrect": [
      "name.length().toUpperCase()",
      "text.contains(\"Bob\").substring(2)"
    ],
    "feedback": "String methods that return String objects can be chained together because each method call returns a new String. Methods like trim(), toUpperCase(), substring(), and replace() return strings and can be chained. However, length() returns an int and contains() returns a boolean, so they can't be chained with String methods."
  },
  {
    "question": "What advantage do functions provide when used inside loops?",
    "correct": [
      "Apply consistent processing to multiple data items",
      "Centralize the logic for repetitive operations",
      "Make it easy to modify the operation for all iterations",
      "Reduce code duplication in repetitive tasks",
      "Process arrays and collections systematically"
    ],
    "incorrect": [],
    "feedback": "Functions in loops provide consistent processing across multiple data items, centralize repetitive logic, make modifications easy (change the function once, affect all iterations), reduce code duplication, and enable systematic processing of collections. This combination is essential for handling arrays, validating multiple inputs, or performing batch operations efficiently."
  },
  {
    "question": "Which function call syntax is correct for a function that takes no parameters?",
    "correct": [
      "getCurrentTime()"
    ],
    "incorrect": [
      "getCurrentTime",
      "getCurrentTime(void)",
      "call getCurrentTime()",
      "getCurrentTime[]"
    ],
    "feedback": "Functions with no parameters are called using the function name followed by empty parentheses. The parentheses are required even when empty to distinguish function calls from variable names. Java doesn't use 'void' in function calls, doesn't require a 'call' keyword, and doesn't use square brackets for function calls."
  },
  {
    "question": "What is the result when this function is called with calculateDiscount(100.0, 0.15)?",
    "correct": [
      "Depends entirely on the function's implementation"
    ],
    "incorrect": [
      "Always returns 15.0",
      "Always returns 85.0",
      "Always returns 115.0",
      "Automatically calculates 15% of 100"
    ],
    "feedback": "The result depends completely on how the calculateDiscount function is implemented. It might return the discount amount (15.0), the final price after discount (85.0), or something else entirely. Function names suggest purpose but don't determine behavior - only the actual code inside the function determines what it returns."
  },
  {
    "question": "Which approach best handles multiple related functions in a program?",
    "correct": [
      "Have functions call other functions as needed",
      "Create functions that work together toward a common goal"
    ],
    "incorrect": [
      "Never allow functions to call other functions",
      "Make every function completely independent",
      "Duplicate code rather than reuse functions"
    ],
    "feedback": "Well-designed programs have functions that call other functions and work together toward common goals. This creates modular, maintainable code where complex tasks are built from simpler functions. Complete independence isn't always practical or efficient, and code duplication violates the DRY (Don't Repeat Yourself) principle of good programming."
  }
]