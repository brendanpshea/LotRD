[
  {
    "question": "What is bytecode in Java?",
    "correct": [
      "Intermediate code produced by the Java compiler that the JVM executes"
    ],
    "incorrect": [
      "The original source code written by programmers",
      "Machine code that runs directly on the processor",
      "Compressed binary files that save disk space",
      "Debugging information embedded in .class files"
    ],
    "feedback": "Bytecode is the intermediate representation created when javac compiles your .java files into .class files. It's not the original source code, not final machine code, and not primarily for compression or debugging. The JVM interprets and executes this bytecode."
  },
  {
    "question": "Which memory area stores object instances in the JVM?",
    "correct": [
      "Heap memory"
    ],
    "incorrect": [
      "Stack memory",
      "Method area",
      "Program counter",
      "Native method stack"
    ],
    "feedback": "The heap is where all objects live in the JVM. Stack memory holds method calls and local variables, the method area stores class-level information like static variables and method bytecode, and other areas serve different purposes."
  },
  {
    "question": "What happens when you call 'java MyProgram' from the command line?",
    "correct": [
      "The JVM loads the MyProgram class and calls its main method"
    ],
    "incorrect": [
      "The Java compiler converts MyProgram.java to bytecode",
      "All .class files in the directory are automatically loaded",
      "The operating system directly executes the bytecode",
      "MyProgram.exe is launched as a native application"
    ],
    "feedback": "The 'java' command starts the JVM, which loads the specified class and looks for its main method as the entry point. Compilation happens with 'javac', not 'java'. Classes are loaded dynamically as needed, and the OS doesn't directly execute bytecode."
  },
  {
    "question": "Which of these is NOT true about exception handling?",
    "correct": [
      "All exceptions must be caught or the program won't compile"
    ],
    "incorrect": [
      "Try-catch blocks can prevent program crashes",
      "Finally blocks always execute regardless of exceptions",
      "Multiple catch blocks can handle different exception types",
      "Exceptions can be thrown manually using the 'throw' keyword"
    ],
    "feedback": "Only checked exceptions must be caught or declared - unchecked exceptions (RuntimeExceptions) don't require explicit handling. All other statements are true: try-catch prevents crashes, finally always runs, multiple catches handle different types, and throw creates exceptions manually."
  },
  {
    "question": "What's the difference between checked and unchecked exceptions?",
    "correct": [
      "Checked exceptions must be handled or declared, unchecked exceptions don't require explicit handling"
    ],
    "incorrect": [
      "Checked exceptions are faster than unchecked exceptions",
      "Unchecked exceptions are more serious than checked exceptions",
      "Checked exceptions occur at compile time, unchecked at runtime",
      "Unchecked exceptions cannot be caught with try-catch blocks"
    ],
    "feedback": "The key difference is compiler enforcement: checked exceptions must be caught or declared in method signatures, while unchecked exceptions are optional to handle. Both occur at runtime, both can be caught, and neither has inherent performance or severity differences."
  },
  {
    "question": "Which exceptions are commonly thrown by this code?\n\nString numStr = getUserInput();\nint value = Integer.parseInt(numStr);\nint[] array = new int[value];\nSystem.out.println(array[0]);",
    "correct": [
      "NumberFormatException if input is not a valid number",
      "NegativeArraySizeException if input is negative"
    ],
    "incorrect": [
      "ArrayIndexOutOfBoundsException when accessing array[0]",
      "NullPointerException from the array access",
      "IllegalArgumentException from creating the array"
    ],
    "feedback": "NumberFormatException occurs if parseInt receives invalid input. NegativeArraySizeException occurs if you try to create an array with negative size. Accessing array[0] is safe since arrays are initialized with default values, so no IndexOutOfBounds or NullPointer exceptions occur here."
  },
  {
    "question": "What will happen in this code?\n\ntry {\n    return \"success\";\n} finally {\n    System.out.println(\"cleanup\");\n}",
    "correct": [
      "\"cleanup\" will be printed, then \"success\" will be returned"
    ],
    "incorrect": [
      "\"success\" will be returned without printing \"cleanup\"",
      "The code will not compile because of the return in try",
      "\"cleanup\" will be printed but nothing will be returned",
      "A runtime exception will be thrown"
    ],
    "feedback": "Finally blocks execute even when there's a return statement in the try block. The finally code runs first, then the return value is returned. This is one of the key guarantees of finally blocks - they always execute."
  },
  {
    "question": "Which statement about the JVM's class loading process is true?",
    "correct": [
      "Classes are loaded dynamically when they are first used"
    ],
    "incorrect": [
      "All classes are loaded immediately when the program starts",
      "Classes are loaded in alphabetical order",
      "Static classes are loaded before instance classes",
      "Classes are loaded from the heap memory"
    ],
    "feedback": "Java uses lazy loading - classes are only loaded when they're actually needed (first reference, object creation, etc.). This improves startup time and memory usage. Loading isn't alphabetical or based on static vs instance, and classes are loaded into the method area, not heap."
  },
  {
    "question": "What does the 'throws' keyword do in a method signature?",
    "correct": [
      "Declares that the method might throw specific checked exceptions"
    ],
    "incorrect": [
      "Automatically throws an exception when the method is called",
      "Prevents the method from throwing any exceptions",
      "Makes all exceptions in the method unchecked",
      "Creates a new exception type for the method"
    ],
    "feedback": "The 'throws' clause is a declaration, not an action - it tells callers which checked exceptions the method might throw so they can handle them. It doesn't throw exceptions automatically, prevent exceptions, change exception types, or create new exception classes."
  },
  {
    "question": "Which of these will prevent a Java program from compiling?",
    "correct": [
      "Missing semicolon at the end of a statement",
      "Calling a method that throws checked exceptions without handling them"
    ],
    "incorrect": [
      "Dividing by zero in arithmetic operations",
      "Accessing null references",
      "Array index out of bounds access"
    ],
    "feedback": "Compilation errors include syntax errors (missing semicolons) and unhandled checked exceptions. Runtime errors like division by zero, null pointer access, and array bounds violations are detected during execution, not compilation."
  },
  {
    "question": "What is the purpose of the stack trace in exception handling?",
    "correct": [
      "Shows the sequence of method calls that led to the exception"
    ],
    "incorrect": [
      "Prevents the exception from crashing the program",
      "Automatically fixes the error that caused the exception",
      "Stores exception objects for later processing",
      "Compresses exception information to save memory"
    ],
    "feedback": "A stack trace is diagnostic information showing the call sequence from main() to the point where the exception occurred. It doesn't prevent crashes, fix errors, store objects, or compress data - it's purely for debugging and understanding what went wrong."
  },
  {
    "question": "Which statements about the 'finally' block are correct?",
    "correct": [
      "Finally blocks execute even if a return statement is in the try block",
      "Finally blocks are commonly used for resource cleanup"
    ],
    "incorrect": [
      "Finally blocks only execute when exceptions occur",
      "You cannot have a finally block without a catch block",
      "Finally blocks can prevent exceptions from propagating"
    ],
    "feedback": "Finally blocks always execute (success or exception), even with return statements, making them perfect for cleanup. You can have try-finally without catch. Finally blocks don't prevent exception propagation - they run, then the exception continues up the call stack."
  },
  {
    "question": "What happens during exception propagation?",
    "correct": [
      "Unhandled exceptions automatically travel up the call stack to calling methods"
    ],
    "incorrect": [
      "All exceptions are automatically converted to RuntimeExceptions",
      "Exceptions are logged to a file and then ignored",
      "The JVM restarts the current method with default parameters",
      "Exception details are sent to the operating system"
    ],
    "feedback": "Exception propagation means unhandled exceptions bubble up through method calls until something catches them or the program terminates. Exceptions aren't converted, logged automatically, don't restart methods, and aren't sent to the OS."
  },
  {
    "question": "Which memory area contains static variables and method definitions?",
    "correct": [
      "Method area (metaspace)"
    ],
    "incorrect": [
      "Heap memory",
      "Stack memory",
      "Program counter register",
      "Direct memory"
    ],
    "feedback": "The method area (also called metaspace in modern JVMs) stores class-level information including static variables, method bytecode, and constant pools. Heap holds object instances, stack holds method calls and local variables."
  },
  {
    "question": "What is NOT true about bytecode execution in the JVM?",
    "correct": [
      "Bytecode is directly executed by the operating system"
    ],
    "incorrect": [
      "The JVM interprets bytecode instructions",
      "Frequently-used bytecode can be compiled to machine code",
      "Bytecode is platform-independent",
      "The same bytecode can run on different operating systems"
    ],
    "feedback": "The operating system never directly executes bytecode - that's the JVM's job. The JVM interprets bytecode, uses JIT compilation for optimization, and provides platform independence by running the same bytecode on different systems."
  },
  {
    "question": "Which exception type indicates a programming error rather than an external problem?",
    "correct": [
      "NullPointerException"
    ],
    "incorrect": [
      "IOException",
      "SQLException",
      "ClassNotFoundException",
      "InterruptedException"
    ],
    "feedback": "NullPointerException indicates a programming bug - trying to use a null reference. IOException (file/network issues), SQLException (database problems), ClassNotFoundException (missing files), and InterruptedException (threading issues) represent external problems that well-written code should handle."
  },
  {
    "question": "What is the correct order of try-catch-finally blocks?",
    "correct": [
      "try, then catch blocks, then finally"
    ],
    "incorrect": [
      "try, then finally, then catch blocks",
      "catch blocks, then try, then finally",
      "finally, then try, then catch blocks",
      "The order doesn't matter as long as all are present"
    ],
    "feedback": "The order must be: try block first, then any catch blocks, then optionally a finally block. This order is enforced by the Java compiler and reflects the logical flow: attempt operation, handle problems, clean up."
  },
  {
    "question": "Which scenarios require explicit exception handling in Java?",
    "correct": [
      "Methods that throw checked exceptions must be handled or declared"
    ],
    "incorrect": [
      "All RuntimeException subclasses must be caught",
      "Methods that use loops must handle IndexOutOfBoundsException",
      "Any method that creates objects must handle OutOfMemoryError",
      "Mathematical operations must handle ArithmeticException"
    ],
    "feedback": "Only checked exceptions require explicit handling or declaration. RuntimeExceptions are unchecked and optional to handle. While it's good practice to handle likely exceptions, the compiler only enforces handling for checked exceptions."
  },
  {
    "question": "What happens when a method's try block contains multiple return statements and an exception occurs?",
    "correct": [
      "The exception overrides any return statements and propagates up"
    ],
    "incorrect": [
      "The first return statement executes, then the exception is thrown",
      "All return statements execute in order, then the exception occurs",
      "The method returns null and suppresses the exception",
      "A compilation error occurs due to multiple returns"
    ],
    "feedback": "When an exception occurs, it immediately stops normal execution and begins exception handling. Any return statements after the exception point are not executed - the exception takes precedence and propagates up the call stack."
  },
  {
    "question": "Which approach demonstrates good exception handling practices?",
    "correct": [
      "Catching specific exception types rather than generic Exception"
    ],
    "incorrect": [
      "Using empty catch blocks to prevent crashes",
      "Converting all exceptions to RuntimeExceptions",
      "Catching exceptions and rethrowing them unchanged",
      "Using exceptions to control normal program flow"
    ],
    "feedback": "Catching specific exceptions allows for targeted handling and better error messages. Empty catch blocks hide problems, unnecessary rethrowing adds no value, converting exceptions loses type information, and exceptions shouldn't control normal flow - they're for error conditions."
  },
  {
    "question": "What is the main benefit of Java's compilation to bytecode approach?",
    "correct": [
      "Platform independence - same bytecode runs on different operating systems"
    ],
    "incorrect": [
      "Faster execution speed compared to interpreted languages",
      "Smaller file sizes compared to source code",
      "Automatic memory management without garbage collection",
      "Direct access to operating system features"
    ],
    "feedback": "Bytecode enables 'write once, run anywhere' - the same .class files work on any system with a JVM. While Java has other performance and memory benefits, platform independence is the primary advantage of the bytecode approach."
  },
  {
    "question": "Which is NOT a valid way to handle a checked exception?",
    "correct": [
      "Ignore it and let the compiler automatically convert it to unchecked"
    ],
    "incorrect": [
      "Catch it with a try-catch block",
      "Declare it in the method signature with 'throws'",
      "Wrap it in a RuntimeException and throw that",
      "Handle it in a calling method that catches it"
    ],
    "feedback": "The compiler never automatically converts checked exceptions to unchecked - you must explicitly handle them. Valid approaches include catching them, declaring them with throws, wrapping them in unchecked exceptions, or letting calling methods handle them."
  },
  {
    "question": "When does the JVM's garbage collector run?",
    "correct": [
      "Automatically when the JVM determines it's needed"
    ],
    "incorrect": [
      "Every time an object goes out of scope",
      "Only when explicitly called with System.gc()",
      "At the end of every method execution",
      "When the finally block executes"
    ],
    "feedback": "Garbage collection is automatic and runs when the JVM decides it's necessary (typically when memory is getting low). It doesn't run when objects go out of scope, System.gc() is just a suggestion, and it's not tied to method execution or finally blocks."
  },
  {
    "question": "What information does an exception object typically contain?",
    "correct": [
      "Error message describing what went wrong",
      "Stack trace showing where the exception occurred"
    ],
    "incorrect": [
      "The source code line that caused the error",
      "Suggestions for automatically fixing the problem",
      "A list of all variables and their values"
    ],
    "feedback": "Exception objects contain a message and stack trace for debugging. They don't include actual source code, don't provide automatic fixes, and don't dump all variable values - that would be a security risk and memory intensive."
  },
  {
    "question": "Which statement about method signatures and exceptions is true?",
    "correct": [
      "Overriding methods cannot throw broader checked exceptions than the parent method"
    ],
    "incorrect": [
      "Overriding methods must throw exactly the same exceptions as the parent",
      "All methods must declare every possible RuntimeException they might throw",
      "The 'throws' clause affects method overloading resolution",
      "Static methods cannot throw checked exceptions"
    ],
    "feedback": "Overriding methods can throw the same or narrower checked exceptions than the parent, but not broader ones (Liskov substitution principle). They don't need to throw exactly the same exceptions, RuntimeExceptions don't need declaration, throws doesn't affect overloading, and static methods can throw checked exceptions."
  },
  {
    "question": "What happens to local variables when a method's stack frame is removed?",
    "correct": [
      "They are immediately deallocated from stack memory"
    ],
    "incorrect": [
      "They are moved to heap memory for garbage collection",
      "They remain accessible to other methods in the class",
      "They are stored in the method area for future calls",
      "They are automatically converted to static variables"
    ],
    "feedback": "Local variables live on the stack and are immediately deallocated when the method ends and its stack frame is popped. They don't move to the heap, aren't accessible to other methods, don't persist for future calls, and don't become static."
  },
  {
    "question": "Which is the most appropriate exception to throw for invalid method parameters?",
    "correct": [
      "IllegalArgumentException"
    ],
    "incorrect": [
      "NullPointerException",
      "RuntimeException",
      "InvalidParameterException",
      "InputMismatchException"
    ],
    "feedback": "IllegalArgumentException is the standard exception for invalid parameters. NullPointerException is for null reference usage, RuntimeException is too generic, InvalidParameterException doesn't exist in standard Java, and InputMismatchException is for input parsing mismatches."
  },
  {
    "question": "What does JIT compilation do in the JVM?",
    "correct": [
      "Converts frequently-used bytecode into optimized machine code at runtime"
    ],
    "incorrect": [
      "Converts source code directly to machine code at compile time",
      "Compresses bytecode files to save disk space",
      "Translates between different versions of Java bytecode",
      "Checks for syntax errors in the source code"
    ],
    "feedback": "Just-In-Time compilation optimizes performance by converting hot bytecode paths to native machine code during execution. It doesn't operate on source code, doesn't compress files, doesn't translate bytecode versions, and doesn't check syntax - that's the compiler's job."
  },
  {
    "question": "Which of these is NOT recommended for exception handling in banking software?",
    "correct": [
      "Using exceptions to control normal business logic flow"
    ],
    "incorrect": [
      "Providing specific error messages for different exception types",
      "Logging exceptions even when they're handled successfully",
      "Using finally blocks for cleanup operations",
      "Catching specific exceptions rather than generic Exception"
    ],
    "feedback": "Exceptions should handle error conditions, not control normal program flow - that's inefficient and confusing. All other practices are recommended: specific error messages help users, logging helps debugging, finally ensures cleanup, and specific catches enable targeted handling."
  }
]