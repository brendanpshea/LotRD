[
  {
    "question": "What is the correct file extension for Java source code files?",
    "correct": [
      ".java"
    ],
    "incorrect": [
      ".class",
      ".jar",
      ".jav",
      ".txt"
    ],
    "feedback": "Java source code files must use the .java extension. This tells the compiler that the file contains Java source code. When compiled with javac, these files produce .class files containing bytecode that can run on any Java Virtual Machine."
  },
  {
    "question": "Which of the following are valid Java variable declarations?",
    "correct": [
      "String customerName = \"Alice\";",
      "boolean isOpen = true;"
    ],
    "incorrect": [
      "int coffee price = 250;",
      "String 2name = \"Bob\";",
      "double price = \"4.50\";"
    ],
    "feedback": "Variable names in Java must follow strict syntax rules: no spaces allowed, cannot start with numbers, and the data type must match the assigned value. String coffee price has a space (invalid), String 2name starts with a number (invalid), and double price = \"4.50\" assigns a string to a double variable (type mismatch)."
  },
  {
    "question": "Which statements about Java data types are correct?",
    "correct": [
      "int is used for whole numbers without decimals",
      "double is appropriate for storing money amounts with cents",
      "String values must be enclosed in double quotes"
    ],
    "incorrect": [
      "boolean can store the values 0 and 1",
      "char values are enclosed in double quotes"
    ],
    "feedback": "Java data types have specific purposes: int stores whole numbers (like 42), double stores decimal numbers (like 4.50), and String stores text in double quotes (like \"Hello\"). Boolean variables can only hold true or false (not 0 and 1), and char values use single quotes ('A'), not double quotes."
  },
  {
    "question": "Which arithmetic operators are valid in Java?",
    "correct": [
      "+",
      "-",
      "*",
      "%"
    ],
    "incorrect": [
      "^"
    ],
    "feedback": "Java uses + for addition, - for subtraction, * for multiplication, / for division, and % for modulus (remainder). The ^ symbol, which represents exponentiation in some mathematical contexts, is not an arithmetic operator in Java - it's actually the XOR operator for bit manipulation."
  },
  {
    "question": "What are the required structural elements of a standalone Java program?",
    "correct": [
      "A class declaration",
      "A main method",
      "Opening and closing braces",
      "The public keyword",
      "The static keyword"
    ],
    "incorrect": [],
    "feedback": "Every standalone Java program must have: a public class declaration, a main method with the exact signature 'public static void main(String[] args)', and proper braces to enclose the class and method code. The public and static keywords are specifically required for the main method that serves as the program entry point."
  },
  {
    "question": "Which demonstrates proper camelCase naming convention in Java?",
    "correct": [
      "customerName"
    ],
    "incorrect": [
      "customer_name",
      "CustomerName",
      "customername",
      "customer-name"
    ],
    "feedback": "CamelCase for variables starts with a lowercase letter and capitalizes the first letter of each subsequent word, with no spaces or special characters. customerName follows this convention. customer_name uses underscores (snake_case), CustomerName starts with uppercase (PascalCase), customername lacks capitalization, and customer-name uses hyphens (not allowed in Java)."
  },
  {
    "question": "Which are true about Java compilation and execution?",
    "correct": [
      "javac creates .class files",
      "java runs compiled programs"
    ],
    "incorrect": [
      "java compiles source code",
      "You can run .java files directly with java",
      "javac runs compiled programs"
    ],
    "feedback": "Java has a two-step process: javac (Java compiler) converts .java source files into .class bytecode files, then java (Java runtime) executes the .class files. You cannot run .java files directly - they must be compiled first. The roles of javac and java are distinct and not interchangeable."
  },
  {
    "question": "Which are valid ways to output text in Java?",
    "correct": [
      "System.out.println(\"Hello\");",
      "System.out.print(\"Hello\");",
      "System.out.println(\"Hello\" + \" World\");"
    ],
    "incorrect": [
      "print(\"Hello\");",
      "println(\"Hello\");"
    ],
    "feedback": "Java requires the full System.out prefix before print methods. System.out.println prints with a newline, System.out.print prints without a newline, and you can concatenate strings with +. Standalone print() or println() methods don't exist in Java - you must use the complete System.out.method syntax."
  },
  {
    "question": "Which data types would store these coffee shop values correctly: customer count (25), price ($4.50), shop name (\"Java Cafe\"), size code ('L')?",
    "correct": [
      "int for customer count",
      "double for price",
      "String for shop name",
      "char for size code"
    ],
    "incorrect": [
      "String for customer count"
    ],
    "feedback": "Each data type serves a specific purpose: int for whole numbers like customer count (25), double for decimal numbers like prices ($4.50), String for text like shop names (\"Java Cafe\"), and char for single characters like size codes ('L'). While you could technically store the customer count as a String, using int is more appropriate for numerical data you might calculate with."
  },
  {
    "question": "What does the modulus operator (%) return?",
    "correct": [
      "The remainder after division"
    ],
    "incorrect": [
      "The quotient of division",
      "The rounded result of division",
      "The decimal part of division",
      "The absolute value of division"
    ],
    "feedback": "The modulus operator (%) returns the remainder left over after division. For example, 17 % 5 equals 2 because 17 ÷ 5 = 3 with a remainder of 2. It's different from the quotient (which would be 3), rounding (which might give 3 or 4), or the decimal part (.4 from 3.4)."
  },
  {
    "question": "Which are valid boolean variable assignments?",
    "correct": [
      "boolean isOpen = true;",
      "boolean isClosed = false;"
    ],
    "incorrect": [
      "boolean isOpen = 1;",
      "boolean isOpen = \"true\";",
      "boolean isOpen = True;"
    ],
    "feedback": "Boolean variables can only be assigned the literals true or false (lowercase). Java doesn't accept 1/0 for true/false like some languages, doesn't accept string values like \"true\", and is case-sensitive so True (uppercase) is invalid. Only the exact keywords true and false work."
  },
  {
    "question": "Which variable names follow Java naming rules?",
    "correct": [
      "_price",
      "$total",
      "coffeePrice"
    ],
    "incorrect": [
      "2cups",
      "coffee-price"
    ],
    "feedback": "Java variable names can start with letters, underscores (_), or dollar signs ($), and can contain letters, numbers, underscores, and dollar signs after the first character. They cannot start with numbers (2cups is invalid) or contain hyphens (coffee-price is invalid). Valid examples include _price, $total, and coffeePrice."
  },
  {
    "question": "What are the results of these expressions: 2 + 3 * 4 and (2 + 3) * 4?",
    "correct": [
      "14 and 20"      
    ],
    "incorrect": [
      "Both equal 20",
      "14 for both",
      "20 and 14"
    ],
    "feedback": "Java follows standard mathematical order of operations (PEMDAS). In 2 + 3 * 4, multiplication happens first: 3 * 4 = 12, then 2 + 12 = 14. In (2 + 3) * 4, parentheses force addition first: (2 + 3) = 5, then 5 * 4 = 20. The parentheses change the order of evaluation and produce different results."
  },
  {
    "question": "Which command compiles Java source code?",
    "correct": [
      "javac"
    ],
    "incorrect": [
      "java",
      "compile",
      "javacompile",
      "javac.exe"
    ],
    "feedback": "The javac command (Java compiler) compiles .java source files into .class bytecode files. The java command runs compiled programs, not compile them. Commands like 'compile' or 'javacompile' don't exist. While javac.exe is the Windows executable file, the command itself is simply 'javac'."
  },
  {
    "question": "Which statements about Java strings are true?",
    "correct": [
      "Strings use double quotes",
      "Strings can contain spaces",
      "Strings can be empty (\"\")",
      "Strings are case-sensitive",
      "Strings can contain numbers as text"
    ],
    "incorrect": [],
    "feedback": "Java strings have several important characteristics: they must be enclosed in double quotes (\"\"), can contain any characters including spaces, can be empty (\"\"), treat uppercase and lowercase as different (\"Hello\" ≠ \"hello\"), and can contain numeric digits as text (\"123\" is different from the number 123). These features make strings very flexible for storing text data."
  },
  {
    "question": "Which escape sequence creates a new line in Java output?",
    "correct": [
      "\\n"
    ],
    "incorrect": [
      "\\t",
      "\\r",
      "\\newline",
      "/n"
    ],
    "feedback": "The escape sequence \\n creates a new line in Java output. Other escape sequences serve different purposes: \\t creates a tab, \\r is a carriage return, \\newline doesn't exist, and /n (without backslash) is just regular text. Escape sequences always start with a backslash followed by a specific character."
  },
  {
    "question": "Which are characteristics of the int data type?",
    "correct": [
      "Stores whole numbers only",
      "Range is approximately -2 billion to +2 billion"
    ],
    "incorrect": [
      "Can store decimal values",
      "Range is unlimited",
      "Uses 64 bits of memory"
    ],
    "feedback": "The int data type stores only whole numbers (integers) without decimal places, and has a range from -2,147,483,648 to 2,147,483,647 (about ±2.1 billion). It cannot store decimal values (use double for that), has a limited range (not unlimited), and uses 32 bits of memory (not 64 - that would be long)."
  },
  {
    "question": "Which of these correctly demonstrate char variable usage?",
    "correct": [
      "char size = 'L';",
      "char grade = 'A';",
      "char initial = 'M';"
    ],
    "incorrect": [
      "char size = \"L\";",
      "char word = 'Hello';"
    ],
    "feedback": "The char data type stores exactly one character enclosed in single quotes ('). Valid examples include 'L', 'A', and 'M'. Using double quotes (\"L\") is incorrect for char - that's String syntax. Trying to store multiple characters ('Hello') won't work because char can only hold one character."
  },
  {
    "question": "What files are involved in Java compilation and execution?",
    "correct": [
      ".java files contain source code",
      ".class files contain bytecode",
      "javac creates .class files",
      "java runs .class files"
    ],
    "incorrect": [
      ".java files are executable"
    ],
    "feedback": "Java uses a two-stage process: .java files contain human-readable source code, .class files contain compiled bytecode. The javac compiler reads .java files and produces .class files. The java runtime executes .class files. Source .java files are not directly executable - they must be compiled into .class files first."
  },
  {
    "question": "Which statement about Java's \"Write Once, Run Anywhere\" is correct?",
    "correct": [
      "Java bytecode runs on any Java Virtual Machine"
    ],
    "incorrect": [
      "Java source code runs directly on any computer",
      "Java automatically converts to native machine code",
      "Java programs work without any runtime environment",
      "Java source files are platform independent"
    ],
    "feedback": "Java achieves platform independence through bytecode that runs on the Java Virtual Machine (JVM). Source code must be compiled to bytecode first, then the JVM (which is platform-specific) interprets the bytecode. Java doesn't convert directly to native machine code, requires the JVM runtime environment, and source files themselves aren't executable across platforms."
  },
  {
    "question": "Which demonstrate proper variable initialization?",
    "correct": [
      "double price = 4.50;",
      "int cups = 10;"
    ],
    "incorrect": [
      "double price;",
      "int cups = price * 2;",
      "String name;"
    ],
    "feedback": "Proper initialization gives variables values when they're declared. double price = 4.50; and int cups = 10; both declare and initialize variables correctly. The incorrect options show common mistakes: declaring without initializing (double price;), using an uninitialized variable in calculations (price hasn't been given a value yet), and leaving variables uninitialized (String name;)."
  },
  {
    "question": "What are the differences between println and print?",
    "correct": [
      "println adds a new line after output",
      "print keeps cursor on same line",
      "println moves to next line automatically"
    ],
    "incorrect": [
      "print is faster than println",
      "println can only print strings"
    ],
    "feedback": "The key difference is line handling: println automatically adds a newline character (\\n) after printing, moving the cursor to the next line, while print leaves the cursor on the same line. Both methods can print various data types, not just strings, and performance differences are negligible. The 'ln' in println stands for 'line'."
  },
  {
    "question": "Which would be appropriate uses for boolean variables in a coffee shop program?",
    "correct": [
      "Tracking if shop is open",
      "Recording if drink is decaffeinated",
      "Checking if customer is a loyalty member",
      "Determining if payment was successful"
    ],
    "incorrect": [
      "Storing customer age"
    ],
    "feedback": "Boolean variables are ideal for binary states - things that have exactly two possible values. Shop status (open/closed), drink properties (decaf/regular), membership status (member/non-member), and payment results (successful/failed) all fit this pattern. Customer age is a number that can have many different values, so it requires an int, not a boolean."
  },
  {
    "question": "What type of error occurs with this code: int price = 4.50;?",
    "correct": [
      "Compilation error"
    ],
    "incorrect": [
      "Runtime error",
      "Logic error",
      "No error occurs",
      "Warning message only"
    ],
    "feedback": "This causes a compilation error because Java enforces strict type checking. You cannot assign a double value (4.50) to an int variable (price). The compiler detects this type mismatch before the program runs and refuses to compile the code. This is a safety feature that prevents type-related bugs from occurring at runtime."
  },
  {
    "question": "Which are Java variable naming requirements and conventions?",
    "correct": [
      "Cannot start with numbers",
      "Cannot contain spaces",
      "Cannot use Java keywords",
      "Should use camelCase",
      "Should be descriptive"
    ],
    "incorrect": [],
    "feedback": "Java has both strict rules and style conventions for variable names. Strict rules enforced by the compiler: cannot start with numbers, cannot contain spaces, cannot use reserved keywords like 'class' or 'public'. Style conventions for readable code: use camelCase (customerName), make names descriptive (totalPrice instead of tp), start with lowercase letters. Following these makes code more maintainable."
  },
  {
    "question": "What happens when you try to use an uninitialized local variable?",
    "correct": [
      "Compilation error"
    ],
    "incorrect": [
      "Program runs with unpredictable values",
      "Java initializes it to zero automatically",
      "Runtime exception occurs",
      "Variable gets a random value"
    ],
    "feedback": "Java prevents the use of uninitialized local variables by generating a compilation error. The compiler tracks variable initialization and won't allow you to use a variable before it has been assigned a value. This safety feature prevents bugs that could occur if variables contained random or garbage values. Instance variables (class fields) are automatically initialized, but local variables are not."
  },
  {
    "question": "What are valid applications of the modulus operator?",
    "correct": [
      "Checking if numbers are even or odd",
      "Cycling through a fixed set of options",
      "Finding remainder in division"
    ],
    "incorrect": [
      "Calculating percentages",
      "Rounding decimal numbers"
    ],
    "feedback": "The modulus operator (%) finds remainders after division. This makes it useful for: determining if numbers are even (n % 2 == 0) or odd (n % 2 == 1), cycling through options (day % 7 for days of week), and getting the actual remainder in division problems. It's not used for percentages (that's multiplication) or rounding (that requires different methods)."
  },
  {
    "question": "Which concepts are essential for understanding Java program structure?",
    "correct": [
      "Classes define program templates",
      "Main method is the entry point",
      "Braces group code blocks",
      "Statements end with semicolons"
    ],
    "incorrect": [
      "Programs must have multiple classes"
    ],
    "feedback": "Java program structure relies on several key concepts: classes serve as blueprints that define what a program can do, the main method is where execution begins (public static void main), braces {} group related code into blocks, and semicolons ; mark the end of each statement. Simple programs need only one class, not multiple classes. These structural elements work together to create organized, readable code."
  },
  {
    "question": "What does this expression evaluate to: 17 % 5?",
    "correct": [
      "2"
    ],
    "incorrect": [
      "3",
      "3.4",
      "12",
      "0"
    ],
    "feedback": "The modulus operator (%) returns the remainder after division. To find 17 % 5, we divide: 17 ÷ 5 = 3 with remainder 2. So 17 % 5 = 2. This is different from the quotient (3), the decimal result (3.4), or other mathematical operations. The modulus specifically gives you what's 'left over' after dividing evenly."
  }
]
