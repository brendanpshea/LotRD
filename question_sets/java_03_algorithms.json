[
  {
    "question": "Which of the following are characteristics that a set of instructions must have to qualify as an algorithm?",
    "correct": [
      "Input: Zero or more values are provided",
      "Output: At least one value is produced",
      "Definiteness: Each step is precisely defined",
      "Finiteness: The algorithm must eventually terminate",
      "Effectiveness: Each step is basic enough to be carried out"
    ],
    "incorrect": [
      "Recursion: The algorithm must call itself",
      "Optimization: The algorithm must be the fastest possible solution"
    ],
    "feedback": "An algorithm must have five characteristics: Input (zero or more values provided), Output (at least one result produced), Definiteness (no ambiguous steps), Finiteness (must eventually terminate), and Effectiveness (steps must be executable). Recursion and optimization are not required characteristics—many valid algorithms are iterative and non-optimal."
  },
  {
    "question": "Why does 'Give it some food whenever it looks hungry' fail as an algorithm for feeding a fish?",
    "correct": [
      "It is not definite: 'some food' is ambiguous",
      "It is not effective: determining if a fish 'looks hungry' cannot be reliably carried out"
    ],
    "incorrect": [
      "It has no input",
      "It has no output",
      "It will never terminate"
    ],
    "feedback": "This fails the definiteness test because 'some food' is vague (how much?), and it fails the effectiveness test because 'looks hungry' cannot be reliably determined. It does have implicit input (the fish's state) and output (fed fish), and it would terminate after feeding. A proper algorithm would be: 'At 9:00 AM and 6:00 PM, drop exactly 3 pellets into the tank.'"
  },
  {
    "question": "Which flowchart symbol is used to represent a decision point (yes/no or true/false branch)?",
    "correct": [
      "Diamond"
    ],
    "incorrect": [
      "Rectangle",
      "Oval",
      "Parallelogram",
      "Circle"
    ],
    "feedback": "In standard flowchart notation, a diamond shape represents a decision point where the algorithm branches based on a yes/no or true/false condition. Rectangles represent processes/actions, ovals represent start/end terminals, and parallelograms represent input/output operations."
  },
  {
    "question": "Match the flowchart symbols to their correct purposes:",
    "correct": [
      "Oval/Rounded rectangle: Start or End of algorithm",
      "Rectangle: An action or operation",
      "Parallelogram: Reading input or displaying output"
    ],
    "incorrect": [
      "Diamond: Reading input or displaying output",
      "Rectangle: Yes/No branch point",
      "Oval: An action or operation"
    ],
    "feedback": "Standard flowchart symbols have specific meanings: Ovals mark the start and end terminals, rectangles represent processes or actions being performed, diamonds represent decision points with branches, and parallelograms represent input/output operations like reading data or printing results."
  },
  {
    "question": "In Mermaid flowchart syntax, which correctly creates a diamond-shaped decision node?",
    "correct": [
      "B{Is count > 0?}"
    ],
    "incorrect": [
      "B[Is count > 0?]",
      "B([Is count > 0?])",
      "B[/Is count > 0?/]",
      "B((Is count > 0?))"
    ],
    "feedback": "In Mermaid syntax, curly braces {Text} create a diamond shape for decisions. Square brackets [Text] create rectangles for processes, parentheses with brackets ([Text]) create ovals/stadiums for terminals, and [/Text/] creates parallelograms for input/output."
  },
  {
    "question": "Which statements about linear search are correct?",
    "correct": [
      "It checks each element one by one from the beginning",
      "It works on both sorted and unsorted arrays",
      "It requires no preprocessing or setup",
      "In the worst case, it checks every element in the array"
    ],
    "incorrect": [
      "It requires the array to be sorted first",
      "It always finds the target in log₂(n) comparisons"
    ],
    "feedback": "Linear search (sequential search) starts at the beginning and checks each element until finding the target or reaching the end. Its key advantage is simplicity—it works on any array regardless of order with no setup required. The tradeoff is that worst case performance requires checking all n elements."
  },
  {
    "question": "What does the break statement do in Java?",
    "correct": [
      "Exits the current loop immediately",
      "Exits the current switch statement"
    ],
    "incorrect": [
      "Skips to the next iteration of the loop",
      "Terminates the entire program",
      "Exits all nested loops at once",
      "Pauses execution until user input"
    ],
    "feedback": "The break statement immediately exits the innermost loop or switch statement containing it. It does not skip to the next iteration (that's continue), does not terminate the program (that would be System.exit()), and only exits one level of nesting, not all enclosing loops."
  },
  {
    "question": "What does the continue statement do in Java?",
    "correct": [
      "Skips the rest of the current loop iteration",
      "Proceeds immediately to the next iteration of the loop"
    ],
    "incorrect": [
      "Exits the loop entirely",
      "Restarts the loop from the beginning",
      "Pauses the loop temporarily",
      "Continues to the next case in a switch statement"
    ],
    "feedback": "The continue statement skips any remaining code in the current iteration and jumps to the next iteration of the loop. Unlike break (which exits the loop entirely), continue keeps the loop running. It has no effect on switch statements—that's where break is used."
  },
  {
    "question": "When implementing a sum accumulator, what should the accumulator variable be initialized to?",
    "correct": [
      "0"
    ],
    "incorrect": [
      "1",
      "The first element of the array",
      "-1",
      "Integer.MAX_VALUE"
    ],
    "feedback": "A sum accumulator should be initialized to 0 because 0 is the identity element for addition—adding 0 to any value doesn't change it. This ensures the first addition (0 + firstElement) correctly starts the running total. Initializing to 1 would give an incorrect sum, and other values are used for different patterns."
  },
  {
    "question": "When implementing a max accumulator to find the largest value in an array, what are valid initialization strategies?",
    "correct": [
      "Initialize to the first element of the array",
      "Initialize to Integer.MIN_VALUE"
    ],
    "incorrect": [
      "Initialize to 0",
      "Initialize to Integer.MAX_VALUE",
      "Initialize to -1"
    ],
    "feedback": "A max accumulator should be initialized to either the first element or Integer.MIN_VALUE. Using the first element guarantees a valid starting point from the data. Using Integer.MIN_VALUE ensures any actual value will be larger. Initializing to 0 fails if all values are negative; Integer.MAX_VALUE is for min accumulators; -1 is arbitrary and unreliable."
  },
  {
    "question": "What is the count accumulator pattern used for?",
    "correct": [
      "Counting how many elements meet a certain condition",
      "Tracking the number of occurrences of something"
    ],
    "incorrect": [
      "Finding the position of an element",
      "Calculating the total sum of all elements",
      "Determining the smallest value in a collection"
    ],
    "feedback": "The count accumulator pattern increments a counter each time a condition is met, tracking how many elements satisfy some criteria. It's initialized to 0 and uses count++ inside a conditional. Finding positions is searching, calculating totals is the sum pattern, and finding smallest values is the min pattern."
  },
  {
    "question": "Which are valid types that can be used in a Java switch statement?",
    "correct": [
      "int",
      "char",
      "String"
    ],
    "incorrect": [
      "double",
      "boolean",
      "float"
    ],
    "feedback": "Java switch statements work with int, char, String, byte, short, and enumerated types. They do not work with double, float, or boolean. This restriction exists because switch relies on exact equality matching, which is problematic for floating-point types due to precision issues."
  },
  {
    "question": "What happens if you forget the break statement at the end of a case in a switch?",
    "correct": [
      "Execution falls through to the next case",
      "The code in the next case runs even if its value doesn't match"
    ],
    "incorrect": [
      "A compilation error occurs",
      "The switch statement exits automatically",
      "Only the matching case executes",
      "A runtime exception is thrown"
    ],
    "feedback": "Without break, Java exhibits 'fall-through' behavior—execution continues into the next case regardless of whether that case's value matches. This is occasionally useful for sharing code between cases, but is usually a bug. Java compiles this without error, so it's the programmer's responsibility to include break statements."
  },
  {
    "question": "What is the purpose of the default case in a switch statement?",
    "correct": [
      "It runs when no other case matches",
      "It handles unexpected or invalid input values"
    ],
    "incorrect": [
      "It runs before any other case is checked",
      "It runs after every matching case",
      "It is required for the switch to compile",
      "It resets the switch variable to a default value"
    ],
    "feedback": "The default case acts like 'else' in an if-else chain—it executes when none of the specified case values match the switch expression. It's optional but recommended for handling unexpected inputs gracefully. It doesn't run first, doesn't run after matches, and doesn't modify any variables."
  },
  {
    "question": "In linear search, what is the best case scenario?",
    "correct": [
      "The target element is at the first position (index 0)"
    ],
    "incorrect": [
      "The target element is at the last position",
      "The target element is in the middle of the array",
      "The target element is not in the array",
      "The array is sorted"
    ],
    "feedback": "The best case for linear search occurs when the target is the very first element checked—at index 0. This requires only 1 comparison. Finding the target at the last position or not finding it at all are worst cases (requiring n comparisons). Middle position is average case, and sorted order doesn't affect linear search."
  },
  {
    "question": "In linear search, which scenarios represent the worst case?",
    "correct": [
      "The target element is at the last position",
      "The target element is not in the array"
    ],
    "incorrect": [
      "The target element is at the first position",
      "The array contains only one element",
      "The array is unsorted"
    ],
    "feedback": "Linear search worst case occurs when we must check every element: either the target is last (found after n comparisons) or not present at all (n comparisons to determine absence). First position is best case (1 comparison). A single-element array is trivial. Being unsorted doesn't affect linear search—it always checks sequentially."
  },
  {
    "question": "What is required for binary search to work correctly?",
    "correct": [
      "The array must be sorted"
    ],
    "incorrect": [
      "The array must contain unique elements",
      "The array must have an odd number of elements",
      "The array must contain only positive numbers",
      "The array must be unsorted"
    ],
    "feedback": "Binary search requires a sorted array because it works by comparing the target to the middle element and eliminating half the search space based on whether the target is smaller or larger. Duplicates are fine, any array size works, any values (positive, negative, zero) work—but the data must be in sorted order."
  },
  {
    "question": "How many comparisons does binary search need in the worst case to search an array of 1,000,000 elements?",
    "correct": [
      "About 20 comparisons"
    ],
    "incorrect": [
      "1,000,000 comparisons",
      "500,000 comparisons",
      "1,000 comparisons",
      "100 comparisons"
    ],
    "feedback": "Binary search has worst case log₂(n) comparisons because each comparison eliminates half the remaining elements. For 1,000,000 elements: log₂(1,000,000) ≈ 20. This is dramatically faster than linear search's worst case of 1,000,000 comparisons. The power of halving means even a billion elements only needs about 30 comparisons."
  },
  {
    "question": "What does the String method compareTo() return when comparing two equal strings?",
    "correct": [
      "0"
    ],
    "incorrect": [
      "true",
      "1",
      "-1",
      "The string itself"
    ],
    "feedback": "The compareTo() method returns an integer: 0 if the strings are equal, a negative number if the first string comes before the second alphabetically, and a positive number if the first comes after. It returns a number (not a boolean) because it indicates ordering relationship, not just equality."
  },
  {
    "question": "In the sentinel value pattern for linear search, what does initializing foundIndex to -1 indicate?",
    "correct": [
      "The target has not been found yet",
      "-1 is not a valid array index, so it signals 'not found'"
    ],
    "incorrect": [
      "The search should start from the last element",
      "The array is empty",
      "An error has occurred",
      "The target is at position -1"
    ],
    "feedback": "Using -1 as a sentinel value works because valid array indices start at 0. If foundIndex remains -1 after the search, we know the target wasn't found. This pattern is compact because -1 serves double duty: it's the initial 'not yet found' state and the final 'not in array' indicator. Arrays cannot have index -1."
  },
  {
    "question": "Which correctly describes O(n) time complexity?",
    "correct": [
      "The number of operations grows proportionally with input size",
      "Also called 'linear time'",
      "Doubling the input roughly doubles the operations"
    ],
    "incorrect": [
      "The number of operations stays constant regardless of input size",
      "The number of operations grows with the logarithm of input size",
      "Also called 'logarithmic time'"
    ],
    "feedback": "O(n), or 'linear time,' means operations scale proportionally with input size n. If you double the input, you roughly double the work. This contrasts with O(1) constant time (operations don't change with input size) and O(log n) logarithmic time (operations grow much slower than input size). Linear search is O(n); binary search is O(log n)."
  },
  {
    "question": "When should you use linear search instead of binary search?",
    "correct": [
      "When the array is unsorted",
      "When the array is small",
      "When you only need to search once and sorting would take longer"
    ],
    "incorrect": [
      "When the array is very large and sorted",
      "When you need the fastest possible search on sorted data",
      "When searching millions of records repeatedly"
    ],
    "feedback": "Linear search is preferred when data is unsorted (binary search won't work), when arrays are small (sorting overhead isn't worth it), or for one-time searches where sorting first would cost more than linear searching. For large sorted arrays or repeated searches, binary search is far more efficient."
  },
  {
    "question": "What are the essential components of a loop represented in a flowchart?",
    "correct": [
      "A decision diamond that determines whether to continue",
      "A back-arrow that returns to the condition check",
      "An update step that changes something so the loop eventually ends"
    ],
    "incorrect": [
      "Two separate end terminals",
      "A parallelogram at every step",
      "Exactly three process rectangles"
    ],
    "feedback": "Loop flowcharts require: initialization (before the loop), a decision diamond for the loop condition, the loop body (work done each iteration), an update step (so the loop terminates), and a back-arrow creating the cycle. The number of terminals, parallelograms, and rectangles varies based on what the loop does."
  },
  {
    "question": "Which patterns are types of accumulator patterns?",
    "correct": [
      "Sum accumulator",
      "Count accumulator",
      "Min/Max accumulator",
      "String building accumulator"
    ],
    "incorrect": [
      "Binary accumulator",
      "Search accumulator"
    ],
    "feedback": "Common accumulator patterns include: sum (adding values, initialized to 0), count (counting occurrences, initialized to 0), min/max (tracking extremes, initialized to first element or MIN/MAX_VALUE), and string building (concatenating strings, initialized to empty string). Searching and binary operations are different algorithm categories, not accumulator patterns."
  },
  {
    "question": "What does 'TD' mean in the Mermaid flowchart declaration 'flowchart TD'?",
    "correct": [
      "Top-Down: the flowchart flows from top to bottom"
    ],
    "incorrect": [
      "Two-Dimensional: the flowchart has width and height",
      "Terminal-Decision: the flowchart starts with a terminal and ends with a decision",
      "Total Diagram: all elements will be shown",
      "Time-Dependent: the flowchart shows temporal sequence"
    ],
    "feedback": "In Mermaid syntax, 'TD' stands for Top-Down, meaning the flowchart flows vertically from top to bottom. The alternative is 'LR' (Left-Right) for horizontal flow. These are layout directions, not descriptions of flowchart content or properties."
  }
]