[
  {
    "question": "What is an algorithm?",
    "correct": [
      "A step-by-step procedure for solving a problem"
    ],
    "incorrect": [
      "A type of programming language",
      "A computer program written in Java",
      "A mathematical equation",
      "A flowchart symbol"
    ],
    "feedback": "An algorithm is a step-by-step procedure or set of instructions for solving a problem or completing a task. It's like a recipe or instruction manual that can be followed to achieve a consistent result. Algorithms exist independently of programming languages and can be implemented in any language or even followed manually."
  },
  {
    "question": "Which are characteristics of good algorithms?",
    "correct": [
      "Clear and unambiguous steps",
      "Must eventually terminate"
    ],
    "incorrect": [
      "Must be written in Java",
      "Should run forever",
      "Can have unclear instructions"
    ],
    "feedback": "Good algorithms must be clear (unambiguous steps that leave no room for interpretation) and finite (guaranteed to end after a limited number of steps). They must also be effective (solve the intended problem correctly). The programming language used doesn't determine algorithm quality, and infinite loops are problematic."
  },
  {
    "question": "Which flowchart symbols are used correctly?",
    "correct": [
      "Diamond for if (age >= 21)",
      "Rectangle for total = total + price",
      "Oval for program start"
    ],
    "incorrect": [
      "Rectangle for program start",
      "Diamond for System.out.println()"
    ],
    "feedback": "Flowchart symbols have specific meanings: diamonds represent decision points with yes/no branches (like if statements), rectangles represent processes or actions (assignments, calculations), and ovals mark start and end points. Using incorrect symbols makes flowcharts confusing and non-standard."
  },
  {
    "question": "Which Java statements will compile without errors?",
    "correct": [
      "if (name.equals(\"Leslie\")) { System.out.println(\"Found\"); }",
      "int max = numbers[0];",
      "for (int i = 0; i < array.length; i++) { total += array[i]; }",
      "public static double calculateTax(double amount) { return amount * 0.08; }"
    ],
    "incorrect": [
      "if (name = \"Leslie\") { System.out.println(\"Found\"); }"
    ],
    "feedback": "The correct statements use proper Java syntax: .equals() for string comparison, valid array access, proper for loop structure, and correct function syntax. The incorrect statement uses assignment (=) instead of comparison in an if condition, which creates a compilation error because you cannot assign a string to a boolean context."
  },
  {
    "question": "What happens when linear search finds the target element?",
    "correct": [
      "The search stops immediately",
      "A break statement executes",
      "No more elements are checked",
      "The loop terminates early",
      "The function returns or sets a flag"
    ],
    "incorrect": [],
    "feedback": "When linear search finds the target, it should stop immediately using a break statement to exit the loop, avoiding unnecessary checks of remaining elements. This improves efficiency by terminating the search as soon as the goal is achieved rather than continuing through the entire array."
  },
  {
    "question": "What is wrong with this linear search code: for (int i = 0; i <= array.length; i++)?",
    "correct": [
      "Will cause ArrayIndexOutOfBoundsException"
    ],
    "incorrect": [
      "Uses wrong increment operator",
      "Should start at index 1",
      "Missing semicolons",
      "Uses wrong comparison operator"
    ],
    "feedback": "Using <= instead of < causes the loop to attempt accessing array[array.length], which is one position past the last valid index. Since arrays are zero-indexed, valid indices are 0 to length-1. This creates an ArrayIndexOutOfBoundsException when the invalid index is accessed."
  },
  {
    "question": "Which are valid accumulator initialization patterns?",
    "correct": [
      "int count = 0;",
      "double total = 0.0;"
    ],
    "incorrect": [
      "int count = 1;",
      "String total = \"\";",
      "boolean sum = false;"
    ],
    "feedback": "Accumulators for counting and summing should start at 0 (or 0.0 for doubles) because you're building up from nothing. Starting a counter at 1 would overcount by one. Using String or boolean types for numeric accumulation doesn't make sense and would cause type errors when trying to add numbers."
  },
  {
    "question": "Which code correctly finds the maximum value in an array?",
    "correct": [
      "int max = array[0]; for (int i = 1; i < array.length; i++) { if (array[i] > max) max = array[i]; }"
    ],
    "incorrect": [
      "int max = 0; for (int i = 0; i < array.length; i++) { if (array[i] > max) max = array[i]; }",
      "int max = array[0]; for (int i = 0; i < array.length; i++) { if (array[i] > max) max = array[i]; }"
    ],
    "feedback": "Correct maximum-finding initializes max with the first array element and starts the loop at index 1. Starting max at 0 fails with arrays containing only negative numbers. Starting the loop at index 0 wastes time comparing the first element to itself unnecessarily."
  },
  {
    "question": "What does the break statement accomplish in loops?",
    "correct": [
      "Immediately exits the current loop",
      "Transfers control to code after the loop",
      "Stops all remaining iterations",
      "Used to exit early when condition is met"
    ],
    "incorrect": [
      "Exits all nested loops simultaneously"
    ],
    "feedback": "The break statement immediately terminates the current loop and transfers control to the first statement after that loop. It's essential for early termination when a goal is achieved (like finding a search target). However, break only exits the innermost loop - it doesn't affect outer loops in nested structures."
  },
  {
    "question": "Which represents the best case for linear search?",
    "correct": [
      "Target found at index 0"
    ],
    "incorrect": [
      "Target found at last index",
      "Target not found in array",
      "Array is already sorted",
      "Array contains no duplicates"
    ],
    "feedback": "Linear search best case occurs when the target is at the first position (index 0), requiring only one comparison. The worst case is finding the target at the end or not finding it at all. Whether the array is sorted or contains duplicates doesn't affect linear search performance since it checks elements sequentially regardless."
  },
  {
    "question": "Which string comparison methods work reliably in Java?",
    "correct": [
      "string1.equals(string2)",
      "\"Leslie\".equals(name)"
    ],
    "incorrect": [
      "string1 == string2",
      "string1.compare(string2)",
      "equals(string1, string2)"
    ],
    "feedback": "Use .equals() method to reliably compare string content in Java. The == operator compares object references, not content, and can give inconsistent results. There's no compare() method that returns boolean, and equals() is a method called on string objects, not a standalone function."
  },
  {
    "question": "What are the essential components of a Java function?",
    "correct": [
      "Return type specification",
      "Function name",
      "Parameter list in parentheses"
    ],
    "incorrect": [
      "Must always return a value",
      "Cannot have more than two parameters"
    ],
    "feedback": "Java functions require a return type (including void), a function name, and parameters in parentheses (even if empty). Functions with void return type don't return values, and functions can have any number of parameters. The 'public static' keywords are needed for functions called from main, but aren't universal requirements."
  },
  {
    "question": "Which Java function declarations are syntactically correct?",
    "correct": [
      "public static void printMessage(String text) { System.out.println(text); }",
      "public static int add(int a, int b) { return a + b; }",
      "public static double calculateArea(double radius) { return 3.14159 * radius * radius; }",
      "public static boolean isEligible(int age) { return age >= 18; }"
    ],
    "incorrect": [
      "public static return int getValue() { return 42; }"
    ],
    "feedback": "Correct function syntax places the return type before the function name, not after 'static'. Parameters need both type and name. The return statement must provide a value matching the return type (or no value for void functions). The incorrect example puts 'return' in the wrong position in the declaration."
  },
  {
    "question": "What makes linear search different from other search algorithms?",
    "correct": [
      "Checks elements one by one in sequence"
    ],
    "incorrect": [
      "Only works with sorted arrays",
      "Always finds elements faster",
      "Uses less memory than other methods",
      "Can only search for numbers"
    ],
    "feedback": "Linear search's defining characteristic is sequential examination of elements one by one until the target is found or the end is reached. Unlike binary search, it works with unsorted data but is generally slower for large datasets. It doesn't inherently use less memory and can search for any data type that supports equality comparison."
  },
  {
    "question": "Which are benefits of using functions in programming?",
    "correct": [
      "Code can be reused in multiple places",
      "Easier to test individual pieces",
      "Reduces code duplication",
      "Makes programs more organized",
      "Simplifies debugging and maintenance"
    ],
    "incorrect": [],
    "feedback": "Functions provide numerous advantages: they enable code reuse (write once, use many times), make testing easier by isolating functionality, reduce duplication following the DRY principle, improve organization by breaking complex problems into smaller pieces, and simplify maintenance since fixes can be made in one location."
  },
  {
    "question": "What error is likely to occurs with this code: double result = calculateTax();?",
    "correct": [
      "Missing required parameter"
    ],
    "incorrect": [
      "Wrong return type assignment",
      "Function name is invalid",
      "Missing semicolon",
      "Incorrect variable declaration"
    ],
    "feedback": "If calculateTax() is defined to require a parameter (like the amount to calculate tax on), calling it without arguments causes a compilation error. The function call must provide all required parameters with correct types. The variable declaration, assignment, and semicolon are syntactically correct."
  },
  {
    "question": "Which accumulator patterns correctly count specific items?",
    "correct": [
      "if (grade >= 90) { aStudents++; }",
      "if (age < 18) { minors = minors + 1; }"
    ],
    "incorrect": [
      "if (grade >= 90) { aStudents += grade; }",
      "if (age < 18) { minors = age; }",
      "if (score > 100) { count = true; }"
    ],
    "feedback": "Counting requires incrementing by 1 when a condition is met. Use ++ or += 1 to count occurrences. Adding the actual value (like grade) creates a sum, not a count. Assigning the value (like age) overwrites instead of accumulating. Using boolean for counting creates type errors."
  },
  {
    "question": "What happens when this linear search completes without finding the target?",
    "correct": [
      "Loop variable reaches array.length",
      "No break statement executes",
      "All elements have been checked"
    ],
    "incorrect": [
      "Program crashes with an exception",
      "Function automatically returns -1"
    ],
    "feedback": "When linear search doesn't find the target, the loop continues until the termination condition (i < array.length) becomes false, meaning all elements were checked without executing a break. The program doesn't crash - you need additional logic to handle the 'not found' case, typically by checking a flag variable or index value."
  },
  {
    "question": "Which code correctly calculates a running total?",
    "correct": [
      "double total = 0; for (int i = 0; i < prices.length; i++) { total += prices[i]; System.out.println(\"Total so far: \" + total); }"
    ],
    "incorrect": [
      "double total = prices[0]; for (int i = 0; i < prices.length; i++) { total += prices[i]; }",
      "double total = 0; for (int i = 1; i < prices.length; i++) { total += prices[i]; }",
      "double total; for (int i = 0; i < prices.length; i++) { total = prices[i]; }",
      "int total = 0; for (int i = 0; i <= prices.length; i++) { total += prices[i]; }"
    ],
    "feedback": "A running total starts at 0, processes all array elements from index 0, accumulates values with +=, and can display progress. Starting with prices[0] double-counts the first element. Starting the loop at 1 skips the first element. Assignment (=) instead of accumulation (+=) overwrites rather than adds. Using <= creates an out-of-bounds error."
  },
  {
    "question": "What of these are true of return statements in functions?",
    "correct": [
      "Send a value back to the calling code",
      "Immediately exit the function",
      "Provide the result of a calculation",
      "Transfer control back to caller",
      "Must match the declared return type"
    ],
    "incorrect": [],
    "feedback": "Return statements serve multiple purposes: they send a computed value back to the code that called the function, immediately terminate function execution (no subsequent code runs), provide results of calculations or operations, transfer program control back to the caller, and must return a value compatible with the declared return type."
  },
  {
    "question": "Which represents a programming error in Java?",
    "correct": [
      "if (name = \"Tom\") { System.out.println(\"Found\"); }"
    ],
    "incorrect": [
      "if (name.equals(\"Tom\")) { System.out.println(\"Found\"); }",
      "if (age >= 21) { System.out.println(\"Adult\"); }",
      "if (count > 0 && hasPermit) { System.out.println(\"Approved\"); }",
      "if (!isComplete) { System.out.println(\"Still working\"); }"
    ],
    "feedback": "Using assignment (=) instead of comparison in an if condition creates a compilation error because the condition must be boolean, but assignment returns the assigned value. The other examples use correct comparison operators: .equals() for strings, >= for numbers, && for logical AND, and ! for logical NOT."
  },
  {
    "question": "What are characteristics of effective search algorithms?",
    "correct": [
      "Find the target when it exists",
      "Handle the case when target doesn't exist"
    ],
    "incorrect": [
      "Always return a positive number",
      "Never use break statements",
      "Must check every element regardless"
    ],
    "feedback": "Effective search algorithms must correctly identify when the target is found and gracefully handle situations where the target doesn't exist in the data structure. They may return various indicators (indices, booleans, objects) and should use efficiency techniques like break statements to avoid unnecessary work."
  },
  {
    "question": "Which loop structures correctly implement linear search?",
    "correct": [
      "for (int i = 0; i < array.length; i++)",
      "while (i < array.length && !found)"
    ],
    "incorrect": [
      "for (int i = 1; i <= array.length; i++)",
      "while (array[i] != target)",
      "for (int i = array.length; i > 0; i--)"
    ],
    "feedback": "Correct linear search uses standard forward iteration starting at 0 and ending before array.length, or a while loop with proper bounds checking and exit conditions. Starting at 1 skips the first element, using <= causes out-of-bounds errors, accessing array[i] without bounds checking can crash, and backward iteration is non-standard for linear search."
  },
  {
    "question": "What makes an algorithm 'unambiguous'?",
    "correct": [
      "Each step has only one possible interpretation",
      "Instructions are precise and specific",
      "No room for different implementations"
    ],
    "incorrect": [
      "Uses simple vocabulary only",
      "Contains no mathematical operations"
    ],
    "feedback": "Unambiguous algorithms have steps that can only be interpreted one way, with precise and specific instructions that leave no doubt about what action to perform. This doesn't require simple vocabulary or avoiding math - it requires clarity and precision in describing each operation and decision point."
  },
  {
    "question": "Which demonstrates proper accumulator usage for finding maximum?",
    "correct": [
      "int max = scores[0]; for (int i = 1; i < scores.length; i++) { if (scores[i] > max) { max = scores[i]; } }"
    ],
    "incorrect": [
      "int max = 0; for (int i = 0; i < scores.length; i++) { max = Math.max(max, scores[i]); }",
      "int max = Integer.MIN_VALUE; for (int i = 0; i < scores.length; i++) { if (scores[i] > max) { max++; } }",
      "int max = scores[0]; for (int i = 0; i <= scores.length; i++) { if (scores[i] > max) { max = scores[i]; } }",
      "int max; for (int i = 0; i < scores.length; i++) { if (scores[i] > max) { max = scores[i]; } }"
    ],
    "feedback": "Proper maximum-finding initializes with the first array element and starts comparison at index 1. Using Math.max() isn't implementing the pattern manually. Incrementing max instead of assigning the larger value is wrong. Using <= causes out-of-bounds errors. Uninitialized variables cause compilation errors in Java."
  },
  {
    "question": "What are advantages of linear search over more complex algorithms?",
    "correct": [
      "Works with unsorted data",
      "Simple to understand and implement",
      "No preprocessing required",
      "Memory efficient",
      "Handles any data type with equality comparison"
    ],
    "incorrect": [],
    "feedback": "Linear search advantages include working with any data organization (sorted or unsorted), simplicity for understanding and implementation, no need for preprocessing or special data structures, minimal memory overhead beyond the original data, and compatibility with any data type that supports equality testing (strings, objects, primitives)."
  },
  {
    "question": "Which function call will cause a runtime error?",
    "correct": [
      "calculateAverage(numbers) where numbers is an empty array"
    ],
    "incorrect": [
      "calculateTax(100.0) with valid tax rate",
      "isEligible(25) checking age requirements",
      "formatName(\"Leslie\") with string parameter",
      "getDiscount(true) with boolean membership status"
    ],
    "feedback": "Calling calculateAverage() with an empty array causes division by zero when computing total/length, resulting in a runtime error. The other function calls provide valid parameters of correct types and should execute normally, assuming the functions are implemented to handle their expected input ranges."
  },
  {
    "question": "What distinguishes a well-designed function from poorly designed code?",
    "correct": [
      "Performs a single, specific task",
      "Has a clear, descriptive name",
      "Returns meaningful values",
      "Takes appropriate parameters",
      "Can be tested independently"
    ],
    "incorrect": [],
    "feedback": "Well-designed functions focus on one specific task (single responsibility), have names that clearly describe their purpose, return values that are useful to callers, accept parameters that provide necessary input data, and can be tested in isolation. This makes code more maintainable, reusable, and easier to debug than monolithic code blocks."
  },
  {
    "question": "Which array access will definitely cause an ArrayIndexOutOfBoundsException?",
    "correct": [
      "array[array.length] when array has 5 elements"
    ],
    "incorrect": [
      "array[0] when array has 5 elements",
      "array[4] when array has 5 elements",
      "array[array.length - 1] when array has 5 elements",
      "array[2] when array has 5 elements"
    ],
    "feedback": "Accessing array[array.length] always causes an exception because valid indices range from 0 to length-1. For a 5-element array, valid indices are 0, 1, 2, 3, 4. Trying to access index 5 (array.length) goes beyond the array bounds and throws an ArrayIndexOutOfBoundsException at runtime."
  }
]