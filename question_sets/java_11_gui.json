[
  {
    "question": "What is the main difference between command-line interfaces (CLI) and graphical user interfaces (GUI)?",
    "correct": [
      "CLI programs run sequentially from top to bottom, while GUI programs are event-driven"
    ],
    "incorrect": [
      "CLI programs are written in C while GUI programs are written in Java",
      "GUI programs can only run on Windows operating systems",
      "CLI programs cannot accept user input",
      "GUI programs are always faster than CLI programs"
    ],
    "feedback": "The key difference is that CLI programs follow a linear, sequential flow where you control execution order, while GUI programs are event-driven and wait for user actions (clicks, key presses) to trigger responses. The programming paradigm is fundamentally different, not the language or speed."
  },
  {
    "question": "Which statements correctly describe event-driven programming?",
    "correct": [
      "The user controls the flow of execution through their actions",
      "Programs wait for events like button clicks before responding"
    ],
    "incorrect": [
      "Programs execute from top to bottom in a fixed order",
      "Event-driven programs cannot use loops or conditionals",
      "Only GUI applications can be event-driven"
    ],
    "feedback": "Event-driven programming means the user controls when things happen through their interactions. The program creates an interface, registers event listeners, and then waits for user actions to trigger responses. This contrasts with sequential programming where the programmer controls the execution order."
  },
  {
    "question": "What is the purpose of the JFrame class in Swing?",
    "correct": [
      "It creates a window that serves as the main container for GUI components",
      "It provides the top-level window with title bar and borders",
      "It is the foundation that holds buttons, labels, and other components"
    ],
    "incorrect": [
      "It creates individual buttons for user interaction",
      "It automatically arranges components without layout managers"
    ],
    "feedback": "JFrame is the top-level container that creates the actual window you see on screen. It provides the frame (hence the name) with title bar, borders, and close button. All other components (buttons, labels, etc.) are added to the JFrame or its content pane."
  },
  {
    "question": "Which method calls are essential when creating a basic JFrame window?",
    "correct": [
      "setVisible(true) to make the window appear",
      "setSize(width, height) to set the window dimensions",
      "setDefaultCloseOperation() to specify what happens when closing",
      "setTitle() to set the text in the title bar"
    ],
    "incorrect": [
      "setColor() to set the window background"
    ],
    "feedback": "These four methods configure the basic JFrame: setVisible(true) makes it appear (otherwise it exists but is invisible), setSize() determines dimensions, setDefaultCloseOperation() specifies close behavior (usually EXIT_ON_CLOSE), and setTitle() sets the title bar text. Note: setColor() is not a real JFrame method."
  },
  {
    "question": "What happens if you forget to call setVisible(true) on a JFrame?",
    "correct": [
      "The window exists in memory but remains invisible to the user",
      "The program continues running but no window appears on screen",
      "You must explicitly show the window for users to see it",
      "The frame object is created but not displayed",
      "Your GUI components are created but cannot be seen"
    ],
    "feedback": "All five statements describe the same issue: without setVisible(true), the JFrame and all its components exist in memory and are fully functional, but the window doesn't appear on screen. This is a very common beginner mistake - always remember to make your frame visible as the final step!"
  },
  {
    "question": "What is the purpose of a JLabel component?",
    "correct": [
      "To display static text or images to the user"
    ],
    "incorrect": [
      "To accept text input from the user",
      "To create clickable buttons",
      "To arrange other components in rows and columns",
      "To handle button click events"
    ],
    "feedback": "JLabel is a read-only component for displaying information - text, images, or both. Users can see it but cannot click it or edit it. For user input you need JTextField, for clicks you need JButton, and for arranging components you need layout managers."
  },
  {
    "question": "Which statements about JButton are correct?",
    "correct": [
      "It is an interactive component that users can click",
      "It triggers actions in your program when clicked"
    ],
    "incorrect": [
      "It can only display text, not images",
      "Each JFrame can only have one button",
      "Buttons automatically know what to do when clicked without event listeners"
    ],
    "feedback": "JButton creates clickable buttons that trigger actions in your program. You must add ActionListeners to specify what happens when clicked - buttons don't automatically do anything. You can have multiple buttons per frame, and buttons can display text, images, or both."
  },
  {
    "question": "Why do we need layout managers in Swing?",
    "correct": [
      "To automatically arrange components when windows are resized",
      "To handle different screen resolutions and font sizes",
      "To avoid specifying exact pixel coordinates for each component"
    ],
    "incorrect": [
      "Because Swing doesn't allow manual positioning of components",
      "To make programs run faster by optimizing component placement"
    ],
    "feedback": "Layout managers solve the problem of making GUIs work across different screen sizes, resolutions, and when users resize windows. They automatically adjust component positions and sizes based on rules you specify, which is much better than hardcoding pixel coordinates that break on different displays."
  },
  {
    "question": "How does FlowLayout arrange components?",
    "correct": [
      "Left to right in rows, wrapping to the next line when full",
      "Components appear in the order they were added",
      "Similar to how words wrap in a paragraph"
    ],
    "incorrect": [
      "In a grid with all cells the same size",
      "In five regions: north, south, east, west, and center"
    ],
    "feedback": "FlowLayout arranges components like words in a paragraph - left to right, wrapping to the next line when there's no more room. Components keep their preferred size and appear in the order you add them. The grid description is GridLayout, and the five regions describe BorderLayout."
  },
  {
    "question": "Which characteristics describe BorderLayout?",
    "correct": [
      "It divides the container into five regions",
      "The regions are NORTH, SOUTH, EAST, WEST, and CENTER",
      "CENTER region expands to fill available space",
      "Each region can hold only one component directly"
    ],
    "incorrect": [
      "Components wrap to the next line automatically"
    ],
    "feedback": "All four correct statements describe BorderLayout's behavior: five regions with specific names, CENTER grows to fill space, and each region holds one component (though that component can be a panel containing many others). Component wrapping describes FlowLayout, not BorderLayout."
  },
  {
    "question": "What is an event listener in Swing?",
    "correct": [
      "Code that responds when specific events occur, like button clicks"
    ],
    "incorrect": [
      "A component that displays event information to users",
      "A method that prevents events from happening",
      "A debugging tool that logs all GUI interactions",
      "A layout manager that arranges event-handling components"
    ],
    "feedback": "An event listener is your code that 'listens' for and responds to events (user actions). When an event occurs, Swing calls your listener's method automatically. It's not a display component, prevention mechanism, debugging tool, or layout manager - it's the connection between user actions and your code's responses."
  },
  {
    "question": "Which interface is used for handling button clicks in Swing?",
    "correct": [
      "ActionListener with its actionPerformed method",
      "You implement ActionListener to respond to button clicks"
    ],
    "incorrect": [
      "ClickListener with its onClick method",
      "ButtonListener with its buttonClicked method",
      "EventListener with its handleEvent method"
    ],
    "feedback": "ActionListener is the correct interface for button clicks, with one method: actionPerformed(ActionEvent e). The other options sound plausible but are not real Swing interfaces. ActionListener is a functional interface, making it perfect for lambda expressions."
  },
  {
    "question": "How do you register an event listener with a button?",
    "correct": [
      "Call button.addActionListener() with your listener"
    ],
    "incorrect": [
      "Set the button's onClick property",
      "Call button.setListener() with your handler",
      "Pass the listener to the JButton constructor",
      "Use button.registerEvent() with your code"
    ],
    "feedback": "The method is addActionListener() - it registers your listener with the button so it gets notified when clicks occur. The other method names sound reasonable but don't exist in Swing. You can add multiple listeners to the same button if needed."
  },
  {
    "question": "What are the advantages of using lambda expressions for event listeners?",
    "correct": [
      "Less boilerplate code compared to anonymous inner classes",
      "More readable - focus is on what happens, not setup",
      "Works because ActionListener is a functional interface",
      "Represents modern Java style"
    ],
    "incorrect": [
      "Lambda expressions make event handling faster at runtime"
    ],
    "feedback": "Lambda expressions provide cleaner syntax for event listeners: less code, better readability, and modern Java style. They work because ActionListener has exactly one method (functional interface). Performance is essentially identical to anonymous inner classes - the advantage is code clarity, not speed."
  },
  {
    "question": "Which statements about lambda expressions in event handling are correct?",
    "correct": [
      "The parameter represents the ActionEvent object",
      "You can access variables from outside the lambda if they're effectively final",
      "Single-statement lambdas can omit curly braces and return keyword"
    ],
    "incorrect": [
      "Lambdas can only be used with buttons, not other components",
      "Each lambda must explicitly declare parameter types"
    ],
    "feedback": "The event parameter (often named 'e') contains information about what happened. Lambdas can access effectively final variables from their surrounding scope. Single statements don't need braces. Lambdas work with any functional interface, and Java infers parameter types from context."
  },
  {
    "question": "What does the JTextField component do?",
    "correct": [
      "Provides a single-line input box where users can type text",
      "Allows users to enter and edit text",
      "Has getText() method to retrieve what the user typed"
    ],
    "incorrect": [
      "Creates a large multi-line text area for paragraphs",
      "Displays read-only text that users cannot modify"
    ],
    "feedback": "JTextField creates single-line text input boxes. Users can type, edit, and you retrieve the text with getText(). For multi-line input you need JTextArea, and for read-only display you need JLabel. JTextField is specifically for single-line user input."
  },
  {
    "question": "How can users submit text in a JTextField?",
    "correct": [
      "By pressing the Enter key if you add an ActionListener to the field",
      "By clicking a button that reads the field's text"
    ],
    "incorrect": [
      "Text is automatically submitted as users type each character",
      "Users must use a special submit() method on the text field",
      "Only mouse clicks can trigger text submission, not keyboard"
    ],
    "feedback": "There are two common approaches: add an ActionListener directly to the JTextField (fires when Enter is pressed), or add a button that reads the field when clicked. Text isn't automatically submitted as typed, there's no submit() method, and keyboard Enter key definitely works."
  },
  {
    "question": "Why is input validation important when working with text fields?",
    "correct": [
      "Users might type letters when you need numbers",
      "Fields might be left blank when input is required",
      "Input values might be out of acceptable range",
      "You need to handle invalid input gracefully with clear error messages"
    ],
    "incorrect": [
      "Input validation is only needed for password fields"
    ],
    "feedback": "All four correct statements highlight why validation matters: users don't always provide expected input. They might enter wrong data types, leave fields empty, or provide out-of-range values. Good programs validate input and provide helpful error messages. Validation is needed for all types of input, not just passwords."
  },
  {
    "question": "Which approach is recommended for validating integer input from a JTextField?",
    "correct": [
      "Use Integer.parseInt() inside a try-catch block",
      "Use trim() to remove whitespace before parsing",
      "Check if the field is empty before attempting to parse"
    ],
    "incorrect": [
      "Use Integer.valueOf() which never throws exceptions",
      "Prevent users from typing non-numeric characters"
    ],
    "feedback": "Good validation uses try-catch with Integer.parseInt() (which throws NumberFormatException for invalid input), trims whitespace first, and checks for empty strings. Integer.valueOf() also throws exceptions, so it's not safer. While you can prevent non-numeric typing, you still need validation for edge cases."
  },
  {
    "question": "What is the difference between JTextField and JTextArea?",
    "correct": [
      "JTextField is single-line, JTextArea supports multiple lines",
      "JTextArea is better for longer text like comments or descriptions",
      "JTextArea should be placed in a JScrollPane for scrolling",
      "JTextArea has setLineWrap() method for automatic text wrapping"
    ],
    "incorrect": [
      "JTextField allows editing but JTextArea is read-only"
    ],
    "feedback": "The key difference is single-line vs. multi-line. JTextArea supports paragraphs, has line wrapping, and should be in a JScrollPane for long content. Both allow editing by default - for read-only display, call setEditable(false) on either, or just use JLabel."
  },
  {
    "question": "What is the purpose of JCheckBox components?",
    "correct": [
      "To allow users to select or deselect independent options",
      "Multiple checkboxes can be selected simultaneously"
    ],
    "incorrect": [
      "To create mutually exclusive choices where only one can be selected",
      "To display lists of items in dropdown menus",
      "To create text input fields with validation"
    ],
    "feedback": "JCheckBox creates independent yes/no selections where multiple can be checked at once (like pizza toppings). For mutually exclusive choices use JRadioButton, for dropdowns use JComboBox, and for text input use JTextField. The key feature of checkboxes is independent, multiple selections."
  },
  {
    "question": "How do JRadioButton components differ from JCheckBox?",
    "correct": [
      "Radio buttons allow selecting only one option from a group",
      "Radio buttons must be added to a ButtonGroup for mutual exclusion",
      "When you select one radio button, others in the group automatically deselect"
    ],
    "incorrect": [
      "Radio buttons can have multiple selections simultaneously",
      "Radio buttons work without needing a ButtonGroup"
    ],
    "feedback": "Radio buttons are for 'choose exactly one' scenarios. The critical requirement is adding them to a ButtonGroup - without this, they act like independent checkboxes. The ButtonGroup handles the mutual exclusion automatically: selecting one deselects the others."
  },
  {
    "question": "What does JOptionPane provide?",
    "correct": [
      "Simple popup dialogs with a single method call",
      "Message dialogs to display information",
      "Input dialogs to get a single piece of text from users",
      "Confirmation dialogs to ask yes/no questions"
    ],
    "incorrect": [
      "A replacement for JFrame for creating main windows"
    ],
    "feedback": "JOptionPane creates temporary popup dialogs for quick interactions: showing messages, getting input, or asking yes/no questions. These are modal (block other windows) and temporary. JOptionPane doesn't replace JFrame - you still need JFrame for your main application window."
  },
  {
    "question": "Which statements correctly describe modal dialogs?",
    "correct": [
      "They block interaction with other windows until closed",
      "They're designed to grab the user's attention immediately"
    ],
    "incorrect": [
      "They allow users to interact with multiple windows simultaneously",
      "They run in the background without interrupting workflow",
      "They can only be created using JFrame, not JOptionPane"
    ],
    "feedback": "Modal dialogs block other windows until closed - this is by design to force user attention for important messages or decisions. They interrupt workflow intentionally. JOptionPane creates modal dialogs easily. Non-modal dialogs (allowing multi-window interaction) exist but are less common for simple popups."
  },
  {
    "question": "What is the Model in the MVC pattern responsible for?",
    "correct": [
      "Storing application data and state",
      "Implementing business logic and game rules",
      "Knowing nothing about the GUI or how data is displayed"
    ],
    "incorrect": [
      "Creating and arranging GUI components",
      "Handling button click events"
    ],
    "feedback": "The Model contains pure logic and data - no GUI code at all. It can answer questions about state, validate actions, and enforce rules, but knows nothing about buttons, labels, or windows. Creating GUI components is the View's job, and handling events is the Controller's job."
  },
  {
    "question": "What is the View's role in the MVC pattern?",
    "correct": [
      "Creating and arranging all GUI components",
      "Displaying information to users",
      "Capturing user input through forms and buttons",
      "Knowing nothing about business logic or game rules"
    ],
    "incorrect": [
      "Deciding whether a player's move is valid"
    ],
    "feedback": "The View handles everything visual: creating components, arranging layouts, displaying data, and collecting user input. It doesn't make decisions about game logic or data validation - that's the Model's job. The View is just the 'face' that shows information and accepts input."
  },
  {
    "question": "What does the Controller do in MVC?",
    "correct": [
      "Coordinates interaction between Model and View",
      "Receives events from the View like button clicks",
      "Calls Model methods to update state or check rules",
      "Updates the View to reflect Model changes"
    ],
    "incorrect": [
      "Creates all GUI components and layouts"
    ],
    "feedback": "The Controller is the mediator connecting Model and View. It listens for View events, asks the Model to process logic, and tells the View to display results. The Model and View never communicate directly - always through the Controller. Creating GUI is the View's responsibility."
  },
  {
    "question": "What are the main benefits of using MVC architecture?",
    "correct": [
      "Easier to test logic without creating GUI components",
      "Easier to modify - changes stay localized to one component",
      "Same Model can work with different Views",
      "Multiple developers can work on different parts without conflicts",
      "Each class has a clear, single responsibility"
    ],
    "feedback": "All five statements describe MVC advantages: testable logic (run Model without GUI), localized changes (modify View without touching Model), reusable Models (CLI and GUI versions), parallel development (different people on different layers), and clear separation of concerns. These benefits make code more maintainable and professional."
  },
  {
    "question": "In an MVC application, which class should contain game logic like checking if a guess is correct?",
    "correct": [
      "The Model class, as it handles all business logic"
    ],
    "incorrect": [
      "The View class, since it displays the results",
      "The Controller class, since it handles user events",
      "The main application class that creates everything",
      "Game logic should be spread across all three classes"
    ],
    "feedback": "Game logic belongs exclusively in the Model. The View just displays results (doesn't calculate them), the Controller coordinates (doesn't implement rules), and the main class just sets things up. Logic should never be spread across classes - centralized in the Model makes it testable and maintainable."
  },
  {
    "question": "Which statements about testing MVC components are correct?",
    "correct": [
      "You can test the Model without creating any GUI components",
      "The Model can have its own main method for testing",
      "The View can be tested separately to check layout and appearance"
    ],
    "incorrect": [
      "You must test all three components together in every test",
      "Testing requires a running GUI window visible on screen"
    ],
    "feedback": "MVC's separation enables isolated testing: test Model logic with simple method calls (no GUI), test View appearance by running just the View's main method (buttons won't work yet), then test everything together. You don't need all three for every test, and Model tests don't need any visible windows."
  }
]