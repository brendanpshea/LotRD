[
  {
    "question": "What is casting in Java programming?",
    "correct": [
      "Converting data from one type to another"
    ],
    "incorrect": [
      "Creating new variables",
      "Deleting unused objects",
      "Calling methods on objects",
      "Importing external libraries"
    ],
    "feedback": "Casting is the process of converting data from one type to another, such as converting a double to an int or an int to a double. This is necessary when you need to use data in a different format than it's currently stored in. The incorrect options describe other programming operations but not type conversion."
  },
  {
    "question": "Which type conversions happen automatically in Java?",
    "correct": [
      "int to double",
      "byte to int"
    ],
    "incorrect": [
      "double to int",
      "int to byte",
      "String to int"
    ],
    "feedback": "Java automatically performs widening conversions where smaller types are converted to larger types without data loss. An int can automatically become a double, and a byte can automatically become an int. However, narrowing conversions like double to int require explicit casting because they may lose data."
  },
  {
    "question": "Which Java casting statements are syntactically correct?",
    "correct": [
      "(int) 3.7",
      "(double) 5",
      "(char) 65"
    ],
    "incorrect": [
      "int(3.7)",
      "cast int 3.7"
    ],
    "feedback": "Java casting syntax uses parentheses around the target type before the value: (targetType) value. Examples like (int) 3.7 convert a double to int. Java doesn't use function-like syntax int(3.7) or keywords like 'cast' - only the parentheses notation works."
  },
  {
    "question": "What happens when you cast 8.9 to an int using (int) 8.9?",
    "correct": [
      "The result is 8",
      "The decimal portion is truncated",
      "No rounding occurs",
      "The fractional part is discarded"
    ],
    "incorrect": [
      "The result is 9"
    ],
    "feedback": "Explicit casting from double to int truncates (cuts off) the decimal portion without rounding. So (int) 8.9 becomes 8, not 9. This is different from Math.round() which performs proper mathematical rounding. Casting simply discards everything after the decimal point."
  },
  {
    "question": "What are the benefits of using Math.round() instead of casting for number conversion?",
    "correct": [
      "Provides proper mathematical rounding",
      "Rounds 0.5 and above up to the next integer", 
      "More accurate for financial calculations",
      "Follows standard rounding conventions",
      "Prevents truncation errors"
    ],
    "incorrect": [],
    "feedback": "Math.round() performs proper mathematical rounding where 0.5 and above rounds up, while casting simply truncates. For example, Math.round(8.6) gives 9, but (int) 8.6 gives 8. This makes Math.round() more accurate for calculations involving money, measurements, or any situation where proper rounding is important."
  },
  {
    "question": "What does null represent in Java?",
    "correct": [
      "The absence of any object reference"
    ],
    "incorrect": [
      "An empty string",
      "The number zero",
      "An uninitialized primitive variable",
      "A deleted object"
    ],
    "feedback": "In Java, null represents the absence of any object reference - it means the variable doesn't point to any object. This is different from an empty string (which is still a valid String object), zero (which is a number), or uninitialized primitives (which get default values like 0). Null can only be assigned to reference types, not primitives."
  },
  {
    "question": "Which variable declarations can be assigned null?",
    "correct": [
      "String name = null;",
      "int[] scores = null;"
    ],
    "incorrect": [
      "int age = null;",
      "double price = null;",
      "boolean valid = null;"
    ],
    "feedback": "Only reference types (objects and arrays) can be assigned null. Strings and arrays are reference types, so they can hold null values. However, primitive types like int, double, and boolean cannot be null - they always have a value (even if it's a default like 0 or false)."
  },
  {
    "question": "Which code will cause a NullPointerException?",
    "correct": [
      "String name = null; int length = name.length();",
      "String[] movies = null; int count = movies.length;",
      "String title = null; String upper = title.toUpperCase();"
    ],
    "incorrect": [
      "String name = \"\"; int length = name.length();",
      "String title = \"Star Wars\"; int length = title.length();"
    ],
    "feedback": "NullPointerException occurs when you try to call methods or access properties on a reference that contains null. Trying to call length() or toUpperCase() on a null String, or accessing the length property of a null array will crash. However, empty strings are valid objects, so calling methods on them works fine."
  },
  {
    "question": "What is the difference between null and an empty string?",
    "correct": [
      "null means no String object exists",
      "Empty string is a valid object with zero characters",
      "You can call methods on empty strings but not on null",
      "null cannot have its length checked, empty string returns 0"
    ],
    "incorrect": [
      "They are the same thing in Java"
    ],
    "feedback": "null means there is no String object at all, while an empty string (\"\") is a valid String object that happens to contain zero characters. You can safely call methods like length() on an empty string (it returns 0), but calling any method on null causes a NullPointerException. This distinction is crucial for safe programming."
  },
  {
    "question": "How do you safely check if a String variable has meaningful content?",
    "correct": [
      "if (str != null && str.length() > 0)"
    ],
    "incorrect": [
      "if (str.length() > 0)",
      "if (str != \"\")",
      "if (str != null || str.length() > 0)",
      "if (str.equals(\"\") == false)"
    ],
    "feedback": "To safely check for meaningful content, you must first verify the string is not null, then check if it has length. The condition if (str != null && str.length() > 0) does both checks safely. Checking length first without the null check will crash if str is null. Using || instead of && would accept null values as valid."
  },
  {
    "question": "Which are wrapper classes for primitive types?",
    "correct": [
      "Integer for int",
      "Double for double"
    ],
    "incorrect": [
      "String for char",
      "Array for int[]",
      "Number for all numeric types"
    ],
    "feedback": "Wrapper classes are object versions of primitive types: Integer wraps int, Double wraps double, Boolean wraps boolean, etc. String is not a wrapper for char (Character is), arrays don't have wrapper classes, and while Number is a superclass of numeric wrappers, it's not a direct wrapper for any specific primitive type."
  },
  {
    "question": "Which demonstrate correct autoboxing and unboxing?",
    "correct": [
      "Integer num = 42; ",
      "int value = new Integer(42);",
      "Double price = 12.99;"
    ],
    "incorrect": [
      "int num = \"42\"; ",
      "String text = 42; "
    ],
    "feedback": "Autoboxing automatically converts primitives to wrapper objects (int to Integer), while unboxing converts wrapper objects back to primitives. Java handles these conversions automatically in assignments and method calls. However, you cannot convert between unrelated types like String and int without explicit parsing."
  },
  {
    "question": "How do you create a 2D array with 3 rows and 4 columns?",
    "correct": [
      "int[][] grid = new int[3][4];",
      "double[][] matrix = new double[3][4];",
      "String[][] table = new String[3][4];"
    ],
    "incorrect": [
      "int[][] grid = new int[4][3];",
      "int[3][4] grid = new int[][];"
    ],
    "feedback": "2D arrays are declared with two sets of brackets and created with new type[rows][columns]. The first number is rows, the second is columns. So new int[3][4] creates 3 rows with 4 columns each. The syntax must include the type and proper bracket placement."
  },
  {
    "question": "What does this code print: int[][] nums = {{1,2},{3,4}}; System.out.println(nums[1][0]);?",
    "correct": [
      "3"
    ],
    "incorrect": [
      "1",
      "2", 
      "4",
      "Causes an error"
    ],
    "feedback": "The 2D array nums has two rows: {1,2} at index 0 and {3,4} at index 1. Accessing nums[1][0] gets row 1 (the second row {3,4}) and column 0 (the first element), which is 3. Remember that array indices start at 0, so [1][0] means second row, first column."
  },
  {
    "question": "What is a Java package?",
    "correct": [
      "A way to organize related classes together",
      "Similar to folders for organizing code",
      "Prevents naming conflicts between classes",
      "Groups functionality by category",
      "Uses hierarchical naming like java.util.Scanner"
    ],
    "incorrect": [],
    "feedback": "Java packages organize related classes into hierarchical structures, similar to folders on a computer. They prevent naming conflicts (two classes can have the same name if in different packages), group related functionality, and use dot notation like java.util for utility classes. This organization makes large codebases manageable and helps developers find related functionality."
  },
  {
    "question": "Which import statement correctly imports the Scanner class?",
    "correct": [
      "import java.util.Scanner;"
    ],
    "incorrect": [
      "import Scanner;",
      "using java.util.Scanner;",
      "include java.util.Scanner;",
      "import java.util.*;"
    ],
    "feedback": "The correct import syntax is 'import' followed by the full package path and class name: import java.util.Scanner; Java doesn't use 'using' or 'include' keywords like other languages. While import java.util.*; would work (importing all util classes), it's less precise than importing the specific class you need."
  },
  {
    "question": "Which classes are automatically available without import statements?",
    "correct": [
      "String",
      "Math"
    ],
    "incorrect": [
      "Scanner",
      "Random",
      "ArrayList"
    ],
    "feedback": "Classes in the java.lang package (like String, Math, System, Integer) are automatically imported and available without explicit import statements. However, classes from other packages like Scanner (java.util), Random (java.util), and ArrayList (java.util) must be explicitly imported before use."
  },
  {
    "question": "What does Math.round(8.7) return?",
    "correct": [
      "9"
    ],
    "incorrect": [
      "8",
      "8.0",
      "9.0", 
      "Causes an error"
    ],
    "feedback": "Math.round() performs standard mathematical rounding and returns a long integer. Math.round(8.7) returns 9 because 8.7 rounds up to the nearest whole number. The return type is long, not double, so it returns 9 (not 9.0), and it rounds rather than truncates (so not 8)."
  },
  {
    "question": "Which Random class methods generate different types of random values?",
    "correct": [
      "nextInt(10) generates 0-9",
      "nextDouble() generates 0.0-1.0",
      "nextBoolean() generates true or false"
    ],
    "incorrect": [
      "nextInt(10) generates 1-10",
      "nextDouble(100) generates 0-100"
    ],
    "feedback": "Random methods have specific behaviors: nextInt(n) generates 0 to n-1 (so nextInt(10) gives 0-9, not 1-10), nextDouble() generates 0.0 to just under 1.0, and nextBoolean() randomly returns true or false. Note that nextDouble() doesn't take parameters - to get other ranges you multiply the result."
  },
  {
    "question": "How do you properly read a line of text input using Scanner?",
    "correct": [
      "String input = scanner.nextLine();"
    ],
    "incorrect": [
      "String input = scanner.next();",
      "String input = scanner.readLine();",
      "String input = scanner.getString();",
      "String input = scanner.nextString();"
    ],
    "feedback": "Scanner's nextLine() method reads an entire line of input including spaces until the user presses Enter. The next() method only reads until the first space, and the other method names don't exist in the Scanner class. Always use nextLine() when you want to capture complete text input from users."
  },
  {
    "question": "What problem occurs when mixing Scanner's number input methods with nextLine()?",
    "correct": [
      "nextLine() immediately reads the leftover newline character",
      "Number input methods leave newline in the buffer",
      "You need an extra nextLine() call to consume the newline",
      "The newline from pressing Enter isn't consumed by nextInt()"
    ],
    "incorrect": [
      "nextLine() cannot be used after number input"
    ],
    "feedback": "When you use nextInt() or other number input methods, they read the number but leave the newline character (from pressing Enter) in the input buffer. If you then call nextLine(), it immediately reads that leftover newline instead of waiting for new input. The solution is to add an extra nextLine() call after number input to consume the leftover newline."
  },
  {
    "question": "Which demonstrates safe null checking in an enhanced for loop?",
    "correct": [
      "for (String name : names) { if (name != null) { System.out.println(name); } }"
    ],
    "incorrect": [
      "for (String name : names) { System.out.println(name.length()); }",
      "if (names != null) for (String name : names) { System.out.println(name); }"
    ],
    "feedback": "Enhanced for loops iterate through array elements but don't automatically handle null values within the array. You must check each element individually: if (name != null) before calling methods on it. While checking if the array itself is null is good practice, it doesn't protect against null elements within the array."
  },
  {
    "question": "What causes integer overflow in Java?",
    "correct": [
      "When a number exceeds the maximum value an int can store",
      "Results wrap around to negative values",
      "int maximum is about 2.1 billion",
      "Adding to Integer.MAX_VALUE causes overflow"
    ],
    "incorrect": [
      "Java automatically prevents overflow"
    ],
    "feedback": "Integer overflow occurs when arithmetic operations produce results larger than Integer.MAX_VALUE (about 2.1 billion) or smaller than Integer.MIN_VALUE. Instead of throwing an error, Java wraps the value around, so adding 1 to Integer.MAX_VALUE produces Integer.MIN_VALUE (a negative number). Java doesn't automatically prevent this - you must use larger data types or check bounds manually."
  },
  {
    "question": "Which approach correctly handles potential overflow in calculations?",
    "correct": [
      "Use long for large number calculations",
      "Cast to long before performing arithmetic",
      "Check if values exceed Integer.MAX_VALUE"
    ],
    "incorrect": [
      "Java automatically handles overflow",
      "Use double for all integer calculations"
    ],
    "feedback": "To prevent integer overflow, use long for large calculations, cast operands to long before arithmetic (like (long)a + b), or check bounds before calculating. Java doesn't automatically handle overflow, and using double for integer calculations can introduce floating-point precision issues. The key is anticipating when results might exceed int range."
  },
  {
    "question": "What is the difference between truncation and rounding?",
    "correct": [
      "Truncation cuts off the decimal part",
      "Rounding follows mathematical rules",
      "Casting truncates, Math.round() rounds",
      "Rounding considers the decimal value to decide direction"
    ],
    "incorrect": [
      "Truncation and rounding produce the same results"
    ],
    "feedback": "Truncation simply cuts off the decimal portion regardless of its value - (int)8.9 becomes 8. Rounding follows mathematical rules where 0.5 and above rounds up - Math.round(8.9) becomes 9. For values like 8.3, both produce 8, but for 8.7, truncation gives 8 while rounding gives 9. The difference is significant for accuracy in calculations."
  },
  {
    "question": "Which correctly demonstrates 2D array initialization with values?",
    "correct": [
      "int[][] matrix = {{1,2,3},{4,5,6}};"
    ],
    "incorrect": [
      "int[][] matrix = {1,2,3,4,5,6};",
      "int[2][3] matrix = {1,2,3,4,5,6};",
      "int[][] matrix = new int[2][3]{1,2,3,4,5,6};",
      "int[][] matrix = [[1,2,3],[4,5,6]];"
    ],
    "feedback": "2D array initialization uses nested braces where each inner brace represents a row: {{row1 values},{row2 values}}. You cannot initialize a 2D array with a flat list of values, use array size in the variable declaration, combine 'new' with initialization braces, or use square brackets like some other languages. The nested brace syntax clearly shows the row and column structure."
  },
  {
    "question": "What are the benefits of using Java's built-in libraries?",
    "correct": [
      "Save development time by using tested code",
      "Avoid reinventing common functionality",
      "Benefit from optimized, professional implementations",
      "Reduce bugs through proven solutions",
      "Focus on unique problem-solving rather than basic utilities"
    ],
    "incorrect": [],
    "feedback": "Java's built-in libraries provide tested, optimized implementations of common functionality like mathematical operations, random number generation, and user input. Using these libraries saves development time, reduces bugs (since they're professionally tested), and lets you focus on solving your unique problems rather than reimplementing basic utilities. This leads to more reliable and maintainable code."
  },
  {
    "question": "Which statement correctly creates a Random object and generates a number from 1 to 6?",
    "correct": [
      "Random rand = new Random(); int dice = rand.nextInt(6) + 1;"
    ],
    "incorrect": [
      "Random rand = new Random(); int dice = rand.nextInt(1, 6);",
      "Random rand = new Random(6); int dice = rand.nextInt();",
      "Random dice = Random.nextInt(6) + 1;",
      "int dice = Random.nextInt(1, 6);"
    ],
    "feedback": "To create Random objects and generate ranges: first create an instance with 'new Random()', then use nextInt(n) which generates 0 to n-1. For 1-6, use nextInt(6) + 1. Random doesn't have a two-parameter nextInt method, the constructor parameter sets the seed (not range), and Random methods are not static - you need an instance to call them."
  }
]