<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>  
    <title>Loop of the Recursive Dragon</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="game-container">
        <div id="game-root"></div>
    </div>
    <script>
        const WEAPONS = [
            {name: "Apprentice's Debug Dagger", attack_die: 4},
            {name: "Journeyman's Binary Blade", attack_die: 5},
            {name: "Recursive Battle Axe", attack_die: 6},
            {name: "Greater Sword of Stack Overflow", attack_die: 7},
            {name: "Epic Quantum Warhammer", attack_die: 8},
            {name: "Ancient Blade of Deep Learning", attack_die: 9},
            {name: "Legendary Sword of System Core Access", attack_die: 10},
        ];

        const ARMORS = [
            {name: "Initiate's Firewall Robes", defense: 0},
            {name: "Acolyte's Cache Armor", defense: 1},
            {name: "Encryption Mesh Vest", defense: 2},
            {name: "Greater Blockchain Chainmail", defense: 3},
            {name: "Epic Neural Network Plate", defense: 4},
            {name: "Ancient Quantum-Shielded Armor", defense: 5},
            {name: "Legendary Armor of Root Access", defense: 6},
        ];

        async function loadJSON(url) {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Error fetching ${url}`);
            return response.json();
        }

        function rollDice(times, sides) {
            let total = 0;
            for (let i = 0; i < times; i++) {
                total += Math.floor(Math.random() * sides) + 1;
            }
            return total;
        }

        class Player {
            constructor() {
                this.level = 1;
                this.xp = 0;
                this.xp_to_next_level = 50;
                this.max_hit_points = 20;
                this.hit_points = 20;
                this.weapon = WEAPONS[0];
                this.armor = ARMORS[0];
                this.total_correct = 0;
                this.total_incorrect = 0;
            }
        }

        class Monster {
            constructor(data) {
                this.monster_name = data.monster_name;
                this.initial_description = data.initial_description || "";
                this.hit_dice = data.hit_dice;
                this.attack_die = data.attack_die;
                this.defense = data.defense;
                this.hit_points = 0;
                for (let i = 0; i < this.hit_dice; i++) {
                    this.hit_points += rollDice(1, 6);
                }
                this.xp_value = this.hit_dice * 10;
            }
        }

        class GameModel {
            constructor(questions, monsters) {
                this.questions = [...questions];
                this.monsters = monsters;
                this.player = new Player();
                this.current_monster = null;
                this.current_question = null;
                this.questions_asked = 0;

                // Shuffle questions
                for (let i = this.questions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.questions[i], this.questions[j]] = [this.questions[j], this.questions[i]];
                }

                this.questions_to_ask = [...this.questions];
            }

            generateMonster() {
                let valid = this.monsters.filter(m => Math.abs(m.hit_dice - this.player.level) <= 1);
                if (valid.length === 0) valid = this.monsters;
                const chosen = valid[Math.floor(Math.random() * valid.length)];
                return new Monster(chosen);
            }

            nextEncounter() {
                if (!this.current_monster || this.current_monster.hit_points <= 0) {
                    if (this.questions_to_ask.length === 0) {
                        this.current_monster = null;
                        this.current_question = null;
                        return "victory";
                    }
                    this.current_monster = this.generateMonster();
                }

                if (this.questions_to_ask.length > 0) {
                    this.current_question = this.questions_to_ask.shift();
                } else {
                    this.current_question = null;
                    return "no_questions";
                }

                return "continue";
            }

            evaluateAnswer(selectedOptions) {
                const q = this.current_question;
                const correctSet = new Set(q.correct || []);
                const incorrectSet = new Set(q.incorrect || []);
                const selectedSet = new Set(selectedOptions);

                const correctSelections = [...selectedSet].filter(s => correctSet.has(s));
                const incorrectSelections = [...selectedSet].filter(s => incorrectSet.has(s));
                const missedCorrect = [...correctSet].filter(c => !selectedSet.has(c));

                this.player.total_correct += correctSelections.length;
                this.player.total_incorrect += incorrectSelections.length;

                const player_hits = correctSelections.length + ([...incorrectSet].filter(i => !selectedSet.has(i)).length);
                const monster_hits = incorrectSelections.length + missedCorrect.length;

                let player_damage = 0;
                for (let i = 0; i < player_hits; i++) {
                    player_damage += rollDice(1, this.player.weapon.attack_die);
                }

                let monster_damage = 0;
                for (let i = 0; i < monster_hits; i++) {
                    monster_damage += rollDice(1, this.current_monster.attack_die);
                }

                const effective_player_damage = Math.max(player_damage - this.current_monster.defense, 0);
                const effective_monster_damage = Math.max(monster_damage - this.player.armor.defense, 0);

                this.current_monster.hit_points -= effective_player_damage;
                this.player.hit_points -= effective_monster_damage;

                let defeated_monster = false;
                let defeated_player = false;
                let xp_gained = 0;
                let question_repeated = false;

                if (this.current_monster.hit_points <= 0) {
                    defeated_monster = true;
                    xp_gained = this.current_monster.xp_value;
                    this.player.xp += xp_gained;
                    this.checkLevelUp();
                }

                if (this.player.hit_points <= 0) {
                    defeated_player = true;
                }

                if (missedCorrect.length > 0 || incorrectSelections.length > 0) {
                    this.questions_to_ask.push(this.current_question);
                    question_repeated = true;
                }

                this.questions_asked += 1;

                return {
                    effective_player_damage,
                    effective_monster_damage,
                    defeated_monster,
                    defeated_player,
                    xp_gained,
                    question_repeated
                };
            }

            checkLevelUp() {
                while (this.player.xp >= this.player.xp_to_next_level) {
                    this.player.level += 1;
                    this.player.xp_to_next_level += 50;
                    this.player.max_hit_points += 10;
                    this.player.hit_points = this.player.max_hit_points;

                    if (this.player.level <= WEAPONS.length) {
                        this.player.weapon = WEAPONS[this.player.level - 1];
                    }
                    if (this.player.level <= ARMORS.length) {
                        this.player.armor = ARMORS[this.player.level - 1];
                    }
                }
            }
        }

        class GameUI {
            constructor(root, model) {
                this.root = root;
                this.model = model;
            }

            clear() {
                this.root.innerHTML = '';
            }

            showQuestionSetSelection(availableSets, startCallback) {
        this.clear();
        let html = `
            <div class='bbs-container'>
                <div class='title'>Choose Your Question Set</div>
                <div class='section'>
                    Select a question set to begin your adventure.
                </div>
            </div>
        `;
        this.root.insertAdjacentHTML('beforeend', html);

        const select = document.createElement('select');
        availableSets.forEach(set => {
            const option = document.createElement('option');
            option.value = set;
            option.textContent = set;
            select.appendChild(option);
        });
        select.classList.add('question-set-select'); // Added Class

        this.root.appendChild(select);

        const btnContainer = document.createElement('div');
        btnContainer.className = 'button-container'; // Added Class

        const startBtn = document.createElement('button');
        startBtn.textContent = "Load Questions";
        startBtn.onclick = () => {
            const chosenSet = select.value;
            startCallback(chosenSet);
        };
        startBtn.classList.add('action-button'); // Added Class

        btnContainer.appendChild(startBtn);
        this.root.appendChild(btnContainer);
    }

    showInitialScreen(startCallback) {
        this.clear();
        const html = `
            <div class='bbs-container'>
                <div class='title'>Welcome to the Loop of the Recursive Dragon!</div>
                <div class='section'>
                    Face monsters near your level. Answer questions to deal damage and gain XP.
                    Level up to improve gear and health.
                </div>
            </div>
        `;
        this.root.insertAdjacentHTML('beforeend', html);

        const btnContainer = document.createElement('div');
        btnContainer.className = 'button-container'; // Added Class

        const startBtn = document.createElement('button');
        startBtn.textContent = "Start Adventure";
        startBtn.onclick = () => startCallback();
        startBtn.classList.add('action-button'); // Added Class

        btnContainer.appendChild(startBtn);
        this.root.appendChild(btnContainer);
    }

        showEncounter() {
            this.clear();
            const p = this.model.player;
            const m = this.model.current_monster;
            const q = this.model.current_question;

            const encounter_html = `
                <div class='bbs-container'>
                    <div class='title'>Loop of the Recursive Dragon</div>
                    <div class='section'>
                        You encounter <span class='bold underline'>${m.monster_name}</span>! ${m.initial_description}<br>
                        Monster HP: <span class='yellow'>${m.hit_points}</span><br>
                        Your HP: <span class='yellow'>${p.hit_points}/${p.max_hit_points}</span>, Lvl: <span class='yellow'>${p.level}</span>, XP: <span class='yellow'>${p.xp}/${p.xp_to_next_level}</span><br>
                        Weapon: <span class='yellow'>${p.weapon.name}</span>, Armor: <span class='yellow'>${p.armor.name}</span>
                    </div>
                </div>
                <div class='bbs-container'>
                    <div class='section'>
                        <span class='bold'>Question:</span> ${q.question}
                    </div>
                </div>
            `;
            this.root.insertAdjacentHTML('beforeend', encounter_html);

            const options = [...(q.correct || []), ...(q.incorrect || [])];
            for (let i = options.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [options[i], options[j]] = [options[j], options[i]];
            }

            const checkboxContainer = document.createElement('div');
            checkboxContainer.className = 'checkbox-container';

            const checkboxes = [];
            options.forEach(opt => {
                const label = document.createElement('label');
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = opt;
                label.appendChild(cb);
                label.appendChild(document.createTextNode(' ' + opt));
                label.classList.add('checkbox-label'); // Added Class
                checkboxContainer.appendChild(label);
                checkboxes.push(cb);
            });

            this.root.appendChild(checkboxContainer);

            const btnContainer = document.createElement('div');
            btnContainer.className = 'button-container'; // Added Class

            const submitBtn = document.createElement('button');
            submitBtn.textContent = "Submit Answer";
            submitBtn.onclick = () => {
                const selected = checkboxes.filter(c => c.checked).map(c => c.value);
                window.gameController.submitAnswer(selected);
            };
            submitBtn.classList.add('action-button'); // Added Class

            const hintBtn = document.createElement('button');
            hintBtn.textContent = "Show Hint";
            hintBtn.onclick = () => {
                this.showHint(q.hint || "No hint available.");
            };
            hintBtn.classList.add('action-button'); // Added Class

            btnContainer.appendChild(submitBtn);
            btnContainer.appendChild(hintBtn);
            this.root.appendChild(btnContainer);
        }
            showHint(hint) {
                const oldHint = this.root.querySelector('.hint');
                if (oldHint) oldHint.remove();

                const hintDiv = document.createElement('div');
                hintDiv.className = 'bbs-container hint';
                hintDiv.innerHTML = `<div class='section'><span class='cyan'>Hint: ${hint}</span></div>`;
                this.root.appendChild(hintDiv);
            }

            showResults(battleData, continueCallback) {
                this.clear();
                const p = this.model.player;
                const m = this.model.current_monster;
                let html = "<div class='bbs-container'><div class='section'>";
                if (battleData.effective_player_damage > 0) {
                    html += `You deal <span class='yellow'>${battleData.effective_player_damage}</span> damage.<br>`;
                } else {
                    html += "Your attack was ineffective.<br>";
                }

                if (battleData.effective_monster_damage > 0) {
                    html += `The monster hits you for <span class='red'>${battleData.effective_monster_damage}</span> damage.<br>`;
                } else {
                    if (!battleData.defeated_monster && battleData.effective_monster_damage === 0) {
                        html += "The monster cannot penetrate your armor.<br>";
                    } else {
                        html += "No counter-attack from the monster.<br>";
                    }
                }

                if (battleData.defeated_monster) {
                    html += `<span class='bold'>You defeated the monster!</span><br>`;
                    html += `XP gained: <span class='yellow'>${battleData.xp_gained}</span> (Total: ${p.xp}/${p.xp_to_next_level})<br>`;
                }

                if (battleData.defeated_player) {
                    html += `<span class='red bold'>You have been defeated! Game Over.</span></div></div>`;
                    this.root.innerHTML = html;
                    return;
                }

                if (m && m.hit_points > 0) {
                    html += `Monster HP: <span class='yellow'>${m.hit_points}</span><br>`;
                }

                html += `Your HP: <span class='yellow'>${p.hit_points}/${p.max_hit_points}</span><br>`;
                if (battleData.question_repeated) {
                    html += "<span class='cyan'>You will face this question again.</span><br>";
                }
                html += "</div></div>";

                this.root.innerHTML = html;
                const continueBtn = document.createElement('button');
                continueBtn.textContent = "Continue";
                continueBtn.onclick = () => continueCallback();
                this.root.appendChild(continueBtn);
            }

            showVictory() {
                this.clear();
                const p = this.model.player;
                const html = `
                    <div class='bbs-container'>
                        <div class='title'>Victory!</div>
                        <div class='section'>
                            All questions answered.<br>
                            Correct: <span class='yellow'>${p.total_correct}</span><br>
                            Incorrect: <span class='yellow'>${p.total_incorrect}</span><br>
                            Level: <span class='yellow'>${p.level}</span><br>
                            HP: <span class='yellow'>${p.hit_points}/${p.max_hit_points}</span><br>
                            Weapon: <span class='yellow'>${p.weapon.name}</span><br>
                            Armor: <span class='yellow'>${p.armor.name}</span>
                        </div>
                    </div>
                `;
                this.root.innerHTML = html;
            }

            showNoQuestions() {
                this.clear();
                const p = this.model.player;
                const html = `
                    <div class='bbs-container'>
                        <div class='section'>
                            <span class='bold red'>All questions have been answered!</span> The monster flees.
                        </div>
                        <div class='section'>
                            <span class='bold'>Final Stats:</span><br>
                            Correct: <span class='yellow'>${p.total_correct}</span><br>
                            Incorrect: <span class='yellow'>${p.total_incorrect}</span><br>
                            HP: <span class='yellow'>${p.hit_points}/${p.max_hit_points}</span><br>
                            Level: <span class='yellow'>${p.level}</span>
                        </div>
                    </div>
                `;
                this.root.innerHTML = html;
            }

            showGameOver() {
                this.clear();
                const p = this.model.player;
                const html = `
                    <div class='bbs-container'>
                        <div class='title'>Game Over</div>
                        <div class='section'>
                            Correct: <span class='yellow'>${p.total_correct}</span><br>
                            Incorrect: <span class='yellow'>${p.total_incorrect}</span><br>
                            Level: <span class='yellow'>${p.level}</span><br>
                            HP: <span class='yellow'>${p.hit_points}/${p.max_hit_points}</span><br>
                            Weapon: <span class='yellow'>${p.weapon.name}</span><br>
                            Armor: <span class='yellow'>${p.armor.name}</span>
                        </div>
                    </div>
                `;
                this.root.innerHTML = html;
            }
        }

        class GameController {
            constructor() {
                this.root = document.getElementById('game-root');
                this.ui = new GameUI(this.root, null);
                this.showQuestionSetSelection();
            }

            async showQuestionSetSelection() {
                try {
                    // Fetch the list of available question sets from a known JSON index.
                    const availableSets = await loadJSON('question_sets/index.json');
                    this.ui.clear();
                    this.ui.showQuestionSetSelection(availableSets, (chosenSet) => this.loadChosenSet(chosenSet));
                } catch (err) {
                    this.root.innerHTML = `<div class='bbs-container'><div class='section red bold'>Error loading question sets: ${err.message}</div></div>`;
                }
            }

            async loadChosenSet(chosenSet) {
                try {
                    const questions_url = `question_sets/${chosenSet}`;
                    const monsters_url = `assets/monsters.json`;
                    const questions_data = await loadJSON(questions_url);
                    const monsters_data = await loadJSON(monsters_url);
                    this.model = new GameModel(questions_data, monsters_data);
                    this.ui = new GameUI(this.root, this.model);
                    this.ui.showInitialScreen(() => this.startAdventure());
                } catch (err) {
                    this.root.innerHTML = `<div class='bbs-container'><div class='section red bold'>Error loading game data: ${err.message}</div></div>`;
                }
            }

            startAdventure() {
                const status = this.model.nextEncounter();
                this.showEncounterStatus(status);
            }

            showEncounterStatus(status) {
                if (status === "victory") {
                    this.ui.showVictory();
                } else if (status === "no_questions") {
                    this.ui.showNoQuestions();
                } else {
                    this.ui.showEncounter();
                }
            }

            submitAnswer(selected) {
                if (!this.model.current_question) return;
                if (selected.length === 0) {
                    this.ui.showHint("Please select at least one option.");
                    return;
                }
                const battleData = this.model.evaluateAnswer(selected);
                if (battleData.defeated_player) {
                    this.ui.showGameOver();
                    return;
                }
                this.ui.showResults(battleData, () => this.continueAdventure());
            }

            continueAdventure() {
                const status = this.model.nextEncounter();
                this.showEncounterStatus(status);
            }
        }

        // Initialize the game controller and make it globally accessible
        window.gameController = new GameController();
    </script>
</body>
</html>
